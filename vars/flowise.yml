# flowise_admin_pass:     {vault.yml}
# flowise_encryption_key: {vault.yml}
#      anthropic_api_key: {vault.yml}
#         openai_api_key: {vault.yml}
#           groq_api_key: {vault.yml}

flowise_admin_user:
  name: "{{ user_erhhung.fullname }}"
  email: "{{ user_erhhung.email }}"
  password: "{{ flowise_admin_pass }}"

flowise_namespace: flowise
flowise_host_name: flowise # alias of "homelab"

# remember to add flowise.fourteeners.local to pfSense DNS
# as an alias of  homelab.fourteeners.local: 192.168.0.221
# https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_filters.html#products
flowise_fqdn: "{{ [flowise_host_name] | product(search_domains) | map('join','.') | first }}"

flowise_secrets:
  encryption: flowise-encryption
  credentials: flowise-credentials
  database: flowise-database-tls
  ingress: flowise-ingress-tls

# use our image with support for DATABASE_TLS
# and client certificate environment variables
flowise_image:
  pullPolicy: Always
  registry: "{{ harbor_container_registry }}"
  repository: library/flowise
  tag: latest
# flowise_image:
#   pullPolicy: IfNotPresent
#   repository: flowiseai/flowise

flowise_db_name: flowise
flowise_db_user: flowise
# use {{ pgpool_pass }}

# https://github.com/cowboysysop/charts/tree/master/charts/flowise
flowise_chart_version: "6.0.0"
flowise_release_name: flowise

# https://github.com/cowboysysop/charts/tree/master/charts/flowise/values.yaml
flowise_chart_values:
  # not sure why defaults say don't change
  # replicaCount and updateStrategy values
  replicaCount: 1
  updateStrategy:
    type: Recreate
  revisionHistoryLimit: 2

  image: "{{ flowise_image }}"

  extraEnvVars: &env # error|info|verbose|debug
    - name: LOG_LEVEL
      value: debug
    # see logs from components
    - name: DEBUG
      value: "true"
    # used by all external components to validate TLS certificates:
    # https://nodejs.org/api/cli.html#cli_node_extra_ca_certs_file
    - name: NODE_EXTRA_CA_CERTS
      value: /tls/database/ca.crt

  # https://docs.flowiseai.com/configuration/environment-variables#for-credentials
  existingSecret: "{{ flowise_secrets['encryption'] }}"
  existingSecretKeyEncryptionKey: encryption-key

  config:
    # https://docs.flowiseai.com/configuration/running-in-production
    # https://github.com/cowboysysop/charts/tree/master/charts/flowise#queue-mode
    mode: queue

  externalPostgresql:
    # mode=queue
    enabled: true
    host: "{{ pgpool_service_host }}"
    port: "{{ pgpool_service_port }}"
    database: "{{ flowise_db_name }}"
    username: "{{ flowise_db_user }}"
    existingSecret: "{{ flowise_secrets['credentials'] }}"
    existingSecretKeyPassword: postgresql-password

  # couldn't get cluster mode working on external
  # Redis, so just use dedicated instance for now
  redis:
    enabled: true
    # values for cowboysysop/redis subchart:
    # https://github.com/cowboysysop/charts/tree/master/charts/redis/values.yaml
    master:
      persistence:
        enabled: true
        storageClass: "{{ storage_classes['default'] }}"
        accessModes: ["ReadWriteOnce"]
        size: 512Mi

      persistentVolumeClaimRetentionPolicy:
        enabled: true
        whenScaled: Retain
        whenDeleted: Delete

  externalRedis:
    # mode=queue
    enabled: false
    host: "{{ valkey_service_host }}"
    port: "{{ valkey_service_port }}"
    # existingSecret: "{{ flowise_secrets['credentials'] }}"
    # existingSecretKeyPassword: valkey-password
    useTLS: true

  persistence:
    enabled: true
    storageClass: "{{ storage_classes['default'] }}"
    accessModes: ["ReadWriteOnce"]
    size: 512Mi

  # does container really need root privileges?!
  securityContext: &security
    capabilities:
      drop: []
    allowPrivilegeEscalation: true
    readOnlyRootFilesystem: false
    runAsNonRoot: false
    runAsUser: 0
    runAsGroup: 0

  resources:
    requests:
      cpu: 50m
      memory: 512Mi

  readinessProbe: &probe
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 6
  livenessProbe: *probe

  extraVolumes: &volumes
    - name: database-tls
      secret:
        secretName: "{{ flowise_secrets['database'] }}"
        defaultMode: 416 # "0640"
    # init container stores updated CA bundle
    - name: trust-store
      emptyDir: {}
    - name: dotenv
      emptyDir: {}

  extraVolumeMounts: &mounts
    - name: database-tls
      mountPath: /tls/database
      readOnly: true
    # replace system trust store with updated
    # CA bundle created by the init container
    - name: trust-store
      mountPath: /etc/ssl/certs/ca-certificates.crt
      subPath: ca-certificates.crt
      readOnly: true
    - name: dotenv
      # app root dir in container is /usr/src
      mountPath: /usr/src/packages/server/.env
      subPath: .env
      readOnly: true
    - name: dotenv
      mountPath: /usr/src/docker/worker/.env
      subPath: .env
      readOnly: true

  # support for extra init containers is only available
  # in my own forked repo on branch "flowise-redis-tls"
  extraInitContainers: &containers
    # add our private CA cert
    # into system trust store
    - name: update-ca-bundle
      image: "{{ flowise_image.registry }}/{{ flowise_image.repository }}:{{ flowise_image.tag }}"
      imagePullPolicy: IfNotPresent
      command:
        - sh
      args:
        - -c
        - |
          set -xe
          # append our CA certs to the system CA bundle.
          # the new ca-certificates.crt will be mounted
          # into main container to replace existing one.
          cat /etc/ssl/certs/ca-certificates.crt /tls/ca.crt <(echo) \
                      > /ssl/ca-certificates.crt
      securityContext:
        runAsUser: 0
        runAsGroup: 0
        readOnlyRootFilesystem: false
      volumeMounts:
        - name: database-tls
          mountPath: /tls/ca.crt
          subPath: ca.crt
          readOnly: true
        - name: trust-store
          mountPath: /ssl

    # the app wants environment variables for PEM-encoded certificates
    # to be base64-encoded contents of those files, presumably because
    # they're defined in .env file during development, but that's very
    # non-Kubernetes practice, where the variables should be pathnames
    - name: create-dotenv
      image: busybox
      imagePullPolicy: IfNotPresent
      command:
        - sh
      args:
        - -c
        - |
          echo "Creating .env file for Flowise..."
          cert="$(base64 -w0 < /tls/tls.crt)"
           key="$(base64 -w0 < /tls/tls.key)"
            ca="$(base64 -w0 < /tls/ca.crt)"

          cat <<EOF > /env/.env
          # https://docs.flowiseai.com/configuration/databases#postgresql
          DATABASE_TLS="true"
          DATABASE_CERT="$cert"
          DATABASE_KEY="$key"
          DATABASE_CA="$ca"
          EOF

          # https://docs.flowiseai.com/configuration/running-flowise-using-queue#queue-mode
          # couldn't get cluster mode working, so
          # these settings are irrelevant for now
          REDIS_CLUSTER="true"
          REDIS_TLS="true"
          REDIS_CERT="$cert"
          REDIS_KEY="$key"
          REDIS_CA="$ca"
          echo ".env file successfully created ✓"
      volumeMounts:
        - name: dotenv
          mountPath: /env
        - name: database-tls
          mountPath: /tls
          readOnly: true

  ingress:
    enabled: true
    tls:
      - secretName: "{{ flowise_secrets['ingress'] }}"
        hosts: "{{ [flowise_fqdn] }}"
    ingressClassName: "{{ rke_ingress_class }}"
    annotations:
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/backend-protocol: HTTP
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-timeouts
      nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
      # allow uploading large files and prevent 413 (Entity
      # Too Large) errors; set to "0" to disable size limit:
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#custom-max-body-size
      nginx.ingress.kubernetes.io/proxy-body-size: 10m
    hosts:
      - host: "{{ flowise_fqdn }}"
        paths: ["/"]
    pathType: Prefix

  worker:
    # mode=queue
    enabled: true
    replicaCount: 1
    revisionHistoryLimit: 2

    image:
      pullPolicy: "{{ flowise_image.pullPolicy }}"
      registry: "{{ flowise_image.registry }}"
      repository: "{{ flowise_image.repository }}-worker"
      tag: "{{ flowise_image.tag }}"

    resources:
      requests:
        cpu: 50m
        memory: 512Mi

    securityContext: *security
    readinessProbe: *probe
    livenessProbe: *probe

    extraEnvVars: *env
    extraVolumes: *volumes
    extraVolumeMounts: *mounts
    extraInitContainers: *containers

  # chart currently doesn't support adding extra init containers
  # (that run BEFORE existing `wait-postgresql` container, which
  # waits until a connection to "flowise" database succeeds), so
  # we must define a Job to create the database if doesn't exist
  extraDeploy:
    - apiVersion: batch/v1
      kind: Job
      metadata:
        name: "{{ flowise_release_name }}-db-init"
      spec:
        ttlSecondsAfterFinished: 120
        template:
          spec:
            restartPolicy: OnFailure
            containers:
              - name: create-database
                image: "{{ postgresql_image }}"
                imagePullPolicy: IfNotPresent
                command:
                  - bash
                args:
                  - -c
                  - |
                    # uses connection params added
                    # by PG* environment variables
                    db_found=$(psql -d postgres -tAc "
                      SELECT COUNT(*) FROM pg_catalog.pg_database WHERE datname = '{{ flowise_db_name }}'
                    ") || exit $?
                    echo "db_found=$db_found"

                    [ "$db_found" -eq 1 ] || {
                      echo -e "\nCreating '{{ flowise_db_name }}' database..."
                      psql -d postgres <<'EOT'

                    -- https://www.postgresql.org/docs/current/sql-createdatabase.html
                    CREATE DATABASE {{ flowise_db_name }} WITH OWNER {{ flowise_db_user }};
                    REVOKE ALL ON DATABASE {{ flowise_db_name }} FROM PUBLIC;
                    GRANT  ALL ON DATABASE {{ flowise_db_name }} TO {{ flowise_db_user }};

                    -- required extensions if using PostgreSQL as a vector store
                    -- (superuser privileges are required to install extensions)
                    -- https://www.postgresql.org/docs/current/sql-createextension.html
                    CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;
                    CREATE EXTENSION IF NOT EXISTS  vector     WITH SCHEMA public;
                    EOT
                    }
                    echo -e "\nDatabase initialization completed ✓"
                env:
                  # https://www.postgresql.org/docs/current/libpq-envars.html
                  - name: PGHOST
                    value: "{{ pgpool_service_host }}"
                  - name: PGUSER
                    value: "{{ postgresql_superuser }}"
                  - name: PGSSLMODE
                    value: verify-full
                  - name: PGSSLCERT
                    value: /tls/tls.crt
                  - name: PGSSLKEY
                    value: /tls/tls.key
                  - name: PGSSLROOTCERT
                    value: /tls/ca.crt
                volumeMounts:
                  - name: superuser-tls
                    mountPath: /tls
                    readOnly: true
            volumes:
              - name: superuser-tls
                secret:
                  secretName: "{{ postgresql_secrets['superuser'] }}"
                  defaultMode: 416 # "0640"

flowise_external_credentials:
  - name: PostgreSQL API
    type: PostgresApi
    data:
      user: "{{ flowise_db_user }}"
      password: "{{ pgpool_pass }}"
  - name: Qdrant Read/Write
    type: qdrantApi
    data:
      qdrantApiKey: "{{ qdrant_api_key.read_write }}"
  - name: Anthropic "Flowise"
    type: anthropicApi
    data:
      anthropicApiKey: "{{ anthropic_api_key }}"
  - name: OpenAI "Default"
    type: openAIApi
    data:
      openAIApiKey: "{{ openai_api_key }}"
  - name: Groq "Flowise"
    type: groqApi
    data:
      groqApiKey: "{{ groq_api_key }}"
