# openwebui_admin_pass:        {vault.yml}
# openwebui_secret_key:        {vault.yml}
# openwebui_pipelines_api_key: {vault.yml}
#              openai_api_key: {vault.yml}

# API request body for
# /api/v1/auths/signup
openwebui_admin_user:
  name: "{{ user_erhhung.fullname }}"
  email: "{{ user_erhhung.email }}"
  password: "{{ openwebui_admin_pass }}"
  # only data URI is allowed, so task
  # will get and re-encode image data
  profile_image_url: "{{ user_erhhung.gravatar }}"

openwebui_namespace: open-webui
openwebui_host_names: # aliases of "ingress"
  - openwebui
  - chatgpt
  - chat

# remember to add openwebui.fourteeners.local (also chatgpt. and chat.)
# to pfSense DNS as aliases of ingress.fourteeners.local: 192.168.4.222
# https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_filters.html#products
openwebui_fqdns: "{{ openwebui_host_names | product(search_domains) | map('join','.') }}"

openwebui_secrets:
  ingress: open-webui-ingress-tls
  database: open-webui-database-tls
  env-vars: open-webui-env-variables

openwebui_replicas: 1

openwebui_db_name: openwebui
openwebui_db_user: openwebui
# use {{ pgpool_pass }}

# https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls
# https://docs.sqlalchemy.org/en/20/dialects/postgresql.html#ssl-connections
# https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING-URIS
# (references "pgpool_service_url" var from vars/postgresql.yml)
openwebui_postgresql_url: >-
  {% set params = {
       'sslmode':     'verify-full',
       'sslcert':     '/tls/database/tls.crt',
       'sslkey':      '/tls/database/tls.key',
       'sslrootcert': '/tls/database/ca.crt'
     } -%}
  {% set items = params | dict2items -%}
  {% set params = items | map(attribute='key')    |
              zip(items | map(attribute='value')) |
                    map('join','=') -%}
  {% set query = params | join('&') -%}
  {{ pgpool_service_url | regex_replace('//',
     '//'~ openwebui_db_user ~':'~ pgpool_pass ~'@')
     }}/{{ openwebui_db_name }}?{{ query }}

# IMPORTANT: add "openwebui:primary" to PgPool's `database_redirect_preference_list`
# so that SQLAlchemy upsert queries don't fail due to read-after-write inconsistency:
# models.tags:insert_new_tag - Error inserting a new tag: Could not refresh instance

# https://redis.readthedocs.io/en/stable/connections.html
# https://redis.readthedocs.io/en/stable/examples/ssl_connection_examples.html
# (references "redis_service_url" var from vars/valkey.yml)
# ssl_cert_reqs: none|optional|required
openwebui_redis_url: >-
  {% set params = {
       'ssl_cert_reqs': 'required',
       'ssl_certfile':  '/tls/database/tls.crt',
       'ssl_keyfile':   '/tls/database/tls.key',
       'ssl_ca_certs':  '/tls/database/ca.crt'
     } -%}
  {% set items = params | dict2items -%}
  {% set params = items | map(attribute='key')    |
              zip(items | map(attribute='value')) |
                    map('join','=') -%}
  {% set query = params | join('&') -%}
  {{ redis_service_url  | regex_replace('//',
     '//:'~ valkey_pass ~'@') }}/0?{{ query }}

# PVC specs for "openwebui_pvcs"
openwebui_pvc_specs:
  # no need for local Chroma DB storage
  # because we connect to Qdrant cluster
  # vector-db:
  #   name: open-webui-vector-db
  #   class: default
  #   size: 2Gi
  #   mount: /app/backend/data/vector_db
  # even though storage provider is S3, Open WebUI
  # still keeps uploaded files in local filesystem:
  # https://github.com/open-webui/open-webui/discussions/15286
  uploads:
    name: open-webui-uploads
    class: single
    size: 2Gi
    mount: /app/backend/data/uploads
  cache:
    name: open-webui-cache
    class: single
    size: 4Gi
    mount: /app/backend/data/cache

# added to "openwebui_extras"
openwebui_pvcs: |
  {% set pvcs = [] %}
  {% for spec in openwebui_pvc_specs.values() %}
  {%   set _  = pvcs.append({
         'apiVersion': 'v1',
         'kind':       'PersistentVolumeClaim',
         'metadata': {
           'name': spec.name
         },
         'spec': {
           'storageClassName': storage_classes[spec.class],
           'accessModes': [
             'ReadWriteMany' if openwebui_replicas > 1 else 'ReadWriteOnce'
           ],
           'resources': {
             'requests': {
               'storage': spec.size
             }
           }
         }
       })   %}
  {% endfor %}
  {{ pvcs   }}

openwebui_volumes:
  - name: database-tls
    secret:
      secretName: "{{ openwebui_secrets['database'] }}"
      defaultMode: 416 # "0640"
  # init container stores updated CA bundle
  - name: trust-store
    emptyDir: {}
  # copy of /app/backend/open_webui/static
  - name: web-static
    emptyDir: {}
  - |
    {% set vols = [] %}
    {% for name, spec in openwebui_pvc_specs.items() %}
    {%   set _  = vols.append({
           'name': name,
           'persistentVolumeClaim': {
             'claimName': spec.name
           }
         })   %}
    {% endfor %}
    {{ vols   }}

openwebui_mounts:
  # client TLS cert to connect to PostgreSQL
  - name: database-tls
    mountPath: /tls/database
    readOnly: true
  # replace system trust store with updated
  # CA bundle created by the init container
  - name: trust-store
    mountPath: /etc/ssl/certs/ca-certificates.crt
    subPath: ca-certificates.crt
    readOnly: true
  # static files with 1000:1000 permissions
  - name: web-static
    mountPath: /app/backend/open_webui/static
    readOnly: false
  - |
    {% set mounts = [] %}
    {% for name, spec in openwebui_pvc_specs.items() %}
    {%   set _  = mounts.append({
           'name':      name,
           'mountPath': spec.mount
         })   %}
    {% endfor %}
    {{ mounts }}

# extra resources for Helm install
openwebui_extras:
  - "{{ openwebui_pvcs }}"

# https://github.com/open-webui/helm-charts/tree/main/charts/open-webui
# IMPORTANT! Playwright deployment should be synchronized with
# Open WebUI so that both Playwright server and client versions
# match. See openwebui_playwright_version in vars/playwright.yml
openwebui_chart_repo_url: https://helm.openwebui.com
openwebui_chart_version: "12.5.0"
openwebui_release_name: open-webui

# comment out `openwebui_app_version` setting below
# to let playbook get `appVersion` value from chart
# https://github.com/open-webui/open-webui/pkgs/container/open-webui/versions?filters%5Bversion_type%5D=tagged
# openwebui_app_version: "0.8.5"

openwebui_image:
  pullPolicy: IfNotPresent
  repository: ghcr.io/open-webui/open-webui
  tag: "{{ openwebui_app_version }}"

  # use our own image with Redis Cluster support
  # (REDIS_CLUSTER_MODE="True") and UID+GID=1000
  # pullPolicy: Always
  # repository: "{{ harbor_container_registry }}/library/open-webui"
  # tag: latest

# Pipelines is open-webui subchart:
# https://github.com/open-webui/helm-charts/tree/main/charts/pipelines/values.yaml
pipelines_chart_values: &pipelines
  replicaCount: 1

  persistence:
    enabled: true

    storageClass: "{{ storage_classes['default'] }}"
    # use ReadWriteMany if replicaCount > 1
    accessModes: ["ReadWriteOnce"]
    # min XFS volume size is 300Mi
    size: 384Mi

  resources:
    requests:
      cpu: 25m
      memory: 96Mi

# https://github.com/open-webui/helm-charts/tree/main/charts/open-webui/values.yaml
openwebui_chart_values:
  replicaCount: "{{ openwebui_replicas }}"
  revisionHistoryLimit: 2

  # use Recreate deployment strategy to avoid
  # multi-attach error on ReadWriteOnce PVCs
  strategy:
    type: Recreate

  # https://docs.openwebui.com/getting-started/advanced-topics/logging
  # (notset/debug/info/warning/error/critical)
  logging:
    # global level
    level: info
    components:
      # Config Management
      config: ""
      # Model Management
      models: ""
      # Authentication Webhook
      webhook: ""
      # Main App Execution
      main: ""
      # Database Operations
      db: ""
      # RAG Operations
      rag: ""
      # Ollama Integration
      ollama: ""
      # OpenAI Integration
      openai: ""
      # Audio Processing
      audio: ""
      # Image Generation
      images: ""
      # ComfyUI Integration
      comfyui: ""

  ollama:
    # don't install another Ollama as we
    # already have it running separately
    enabled: false
  ollamaUrls: "{{ [ollama_service_url] }}"

  # use LiteLLM's OpenAI-compatible API
  # to proxy requests to external model
  # providers and track their spending
  enableOpenaiApi: true
  # if Pipelines is enabled, its endpoint
  # will be first in OPENAI_API_BASE_URLS
  openaiBaseApiUrl: "{{ litellm_service_url }}"

  image: "{{ openwebui_image }}"

  # https://docs.openwebui.com/reference/env-configuration
  commonEnvVars:
    # https://docs.openwebui.com/reference/env-configuration#important-note-on-persistentconfig-environment-variables
    - name: ENABLE_PERSISTENT_CONFIG
      value: "False"
    # enable API /docs
    # https://docs.openwebui.com/reference/api-endpoints#swagger-documentation-links
    # https://docs.openwebui.com/reference/env-configuration#env
    - name: ENV
      value: dev
    - name: USER_AGENT
      value: Open WebUI
    # https://docs.openwebui.com/reference/env-configuration#jwt_expires_in
    - name: JWT_EXPIRES_IN
      value: 8h
    # Qdrant TLS certificate validation:
    # https://grpc.github.io/grpc/core/md_doc_environment_variables.html
    - name: GRPC_DEFAULT_SSL_ROOTS_FILE_PATH
      value: /tls/database/ca.crt
    # MinIO TLS certificate validation:
    # https://docs.aws.amazon.com/sdkref/latest/guide/feature-gen-config.html
    - name: AWS_CA_BUNDLE
      value: /tls/database/ca.crt
    # Open WebUI uses NLTK (Natural Language Toolkit) via `unstructured`
    # to parse and extract text from web pages loaded by Playwright, but
    # NLTK requires data directory to download tokenizers and chunkers:
    # https://github.com/Unstructured-IO/unstructured
    # https://www.nltk.org/data.html
    - name: NLTK_DATA
      # created by init container
      value: /app/backend/data/nltk

  extraEnvVars:
    # must be defined in extraEnvVars!
    - name: WEBUI_URL
      value: https://{{ openwebui_fqdns | first }}
    # https://docs.openwebui.com/reference/env-configuration#cors_allow_origin
    - name: CORS_ALLOW_ORIGIN
      value: https://{{ openwebui_fqdns | first }}
    # the two websocket vars below would have been automatically added
    # by the chart if .websocket.enabled is true, but that would force
    # the inclusion of WEBSOCKET_REDIS_URL as a literal value directly
    # in the pod template--we want to inject using a secretRef instead
    - name: ENABLE_WEBSOCKET_SUPPORT
      value: "True"
    - name: WEBSOCKET_MANAGER
      value: redis
    - name: REDIS_CLUSTER
      value: "True"
    - name: REDIS_KEY_PREFIX
      value: "{open-webui}"
    # https://docs.openwebui.com/reference/env-configuration#vector-database
    - name: VECTOR_DB
      value: qdrant
    # https://docs.openwebui.com/reference/env-configuration#qdrant
    - name: QDRANT_URI
      value: "{{ qdrant_service_url }}"
    # must also set GRPC_DEFAULT_SSL_ROOTS_FILE_PATH!
    - name: QDRANT_PREFER_GRPC
      value: "True"
    - name: QDRANT_GRPC_PORT
      value: "{{ qdrant_grpc_port | string }}"
    # https://qdrant.tech/documentation/concepts/storage#vector-storage
    - name: QDRANT_ON_DISK
      value: "True"
    # https://qdrant.tech/documentation/concepts/collections
    - name: ENABLE_QDRANT_MULTITENANCY_MODE
      value: "True"
    - name: QDRANT_COLLECTION_PREFIX
      value: openwebui

  extraEnvFrom:
    - secretRef:
        name: "{{ openwebui_secrets['env-vars'] }}"

  pipelines:
    # install Pipelines subchart:
    # https://github.com/open-webui/pipelines
    enabled: true
    <<: *pipelines

  # Apache Tika is a content analysis toolkit
  # that can detect and extract metadata and
  # text from over 1000 different file types:
  # https://tika.apache.org/
  # NOTE: Open WebUI, out-of-the-box, without
  # Tika, can parse .txt/.md/.docx/.pdf/.html
  # https://github.com/apache/tika-helm
  tika:
    # https://github.com/apache/tika-helm/tree/main/values.yaml
    enabled: true

    resources:
      requests:
        cpu: 50m
        memory: 256Mi
      limits:
        cpu: 1500m
        memory: 2Gi

    readinessProbe:
      periodSeconds: 10
    livenessProbe:
      periodSeconds: 10

  websocket:
    # enable via .extraEnvVars instead so
    # that REDIS_URL (WEBSOCKET_REDIS_URL
    # fallback) can be defined in secret
    enabled: false
    manager: redis
    redis:
      # use Redis subchart since there
      # is no support for cluster mode
      # enabled: true
      # don't install Redis as we already
      # have a multi-node Valkey cluster
      enabled: false
    # define WEBSOCKET_REDIS_URL
    # url: "{{ openwebui_redis_url }}"

  persistence:
    enabled: true

    # storage provider for uploaded files
    # if local: /app/backend/data/uploads
    # https://docs.openwebui.com/reference/env-configuration#cloud-storage
    provider: s3 # local/s3/gcs/azure
    # https://docs.openwebui.com/reference/env-configuration#amazon-s3-storage
    s3:
      bucket: openwebui
      keyPrefix: uploads/
      accessKey: openwebui
      secretKeyExistingSecret: "{{ openwebui_secrets['env-vars'] }}"
      secretKeyExistingSecretKey: S3_SECRET_ACCESS_KEY
      # IMPORTANT: since Helm chart provides no method to specify
      # TLS config, environment var AWS_CA_BUNDLE must be defined
      endpointUrl: "{{ minio_service_url }}"
      region: "{{ minio_region }}"

  podSecurityContext:
    fsGroup: 2000
  containerSecurityContext:
    capabilities:
      drop: ["ALL"]
    # NOTE: the Open WebUI custom image must be built with proper UID+GID args:
    # docker build --build-arg UID=1000 --build-arg GID=1000 --tag open-webui .
    runAsUser: 1000
    runAsGroup: 1000
    runAsNonRoot: true
    readOnlyRootFilesystem: false

  resources:
    requests:
      cpu: 50m
      memory: 768Mi
    limits:
      cpu: 1000m

  # database bootstrapping and model downloads can take a
  # long time, especially if cluster load is already high
  startupProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 60
    periodSeconds: 5
    timeoutSeconds: 5
    failureThreshold: 48
  readinessProbe: &probe
    httpGet:
      path: /health/db
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
  livenessProbe:
    <<: *probe
    httpGet:
      path: /health
      port: http

  # mount database TLS secret and
  # PVCs for vector DB and cache
  volumes: "{{ openwebui_volumes | flatten }}"
  volumeMounts:
    container: "{{ openwebui_mounts | flatten }}"

  extraInitContainers:
    # create PostgreSQL database
    # openwebui if doesn't exist
    - name: create-database
      image: "{{ postgresql_image }}"
      imagePullPolicy: IfNotPresent
      command: ["bash"]
      args:
        - -c
        - |-
          # uses connection params added
          # by PG* environment variables
          db_found=$(psql -d postgres -tAc "
            SELECT COUNT(*) FROM pg_catalog.pg_database WHERE datname = '$PGDATABASE'
          ") || exit $?
          echo "db_found=$db_found"

          [ "$db_found" -eq 1 ] || {
            echo -e "\nCreating '$PGDATABASE' database..."
            psql -d postgres <<EOT

          -- https://www.postgresql.org/docs/current/sql-createdatabase.html
          CREATE DATABASE $PGDATABASE WITH OWNER $PGUSER;
          REVOKE ALL ON DATABASE $PGDATABASE FROM PUBLIC;
          GRANT  ALL ON DATABASE $PGDATABASE  TO $PGUSER;
          EOT
          }
          echo -e "\nDatabase initialization completed âœ“"
      env:
        # https://www.postgresql.org/docs/current/libpq-envars.html
        - name: PGHOST
          value: "{{ pgpool_service_host }}"
        - name: PGUSER
          value: "{{ openwebui_db_user }}"
        - name: PGDATABASE
          value: "{{ openwebui_db_name }}"
        - name: PGSSLMODE
          value: verify-full
        - name: PGSSLCERT
          value: /tls/tls.crt
        - name: PGSSLKEY
          value: /tls/tls.key
        - name: PGSSLROOTCERT
          value: /tls/ca.crt
      volumeMounts:
        - name: database-tls
          mountPath: /tls
          readOnly: true

    # add our private CA cert
    # into system trust store
    - name: update-ca-bundle
      image: "{{ openwebui_image.repository }}:{{ openwebui_image.tag }}"
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 0
      command: ["sh"]
      args:
        - -c
        - |-
          set -xe
          # copy our CA certs to standard extra certs dir
          cp /tls/ca.crt /usr/local/share/ca-certificates
          update-ca-certificates 2> /dev/null

          # copy updated CA bundle containing extra certs
          # from /usr/local/share/ca-certificates and all
          # already in trust store under /etc/ssl/certs.
          # the new ca-certificates.crt will be mounted
          # into main container to replace existing one.
          cp /etc/ssl/certs/ca-certificates.crt /ssl
      volumeMounts:
        - name: database-tls
          mountPath: /tls/ca.crt
          subPath: ca.crt
          readOnly: true
        - name: trust-store
          mountPath: /ssl

    # duplicate /app/backend/open_webui/static files in
    # emptyDir and change file permissions to 1000:1000
    - name: fix-permissions
      image: "{{ openwebui_image.repository }}:{{ openwebui_image.tag }}"
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 0
      command: ["sh"]
      args:
        - -c
        - |-
          set -ex
          mkdir -p /data/nltk
          cp -a /app/backend/open_webui/static/. /static
          chown -R 1000:1000 /data /static
          ls -l /static
      volumeMounts:
        - name: data
          mountPath: /data
        - name: web-static
          mountPath: /static

  managedCertificate:
    # create our own ingress
    # TLS secret via Ansible
    enabled: false

  ingress:
    enabled: true
    tls: true
    existingSecret: "{{ openwebui_secrets['ingress'] }}"
    class: "{{ rke_ingress_class }}"
    annotations:
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/backend-protocol: HTTP
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations#custom-timeouts
      nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
      # allow uploading large files and prevent 413 (Entity
      # Too Large) errors; set to "0" to disable size limit:
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations#custom-max-body-size
      nginx.ingress.kubernetes.io/proxy-body-size: 10m
    host: "{{ openwebui_fqdns[0] }}"
    additionalHosts: "{{ openwebui_fqdns[1:] }}"

  extraResources: "{{ openwebui_extras | flatten }}"

# user Settings > General > System prompt
# https://docs.openwebui.com/features/ai-knowledge/prompts#prompt-variables
openwebui_system_prompt: >-
  {% raw -%}
  Today is {{CURRENT_DATE}}, and the current time is
  {{CURRENT_TIME}}. User's full name is {{USER_NAME}},
  but address the user by first name.
  {%- endraw %}

# admin Settings > Web Search > General
# POST /api/v1/retrieval/config/update
openwebui_retrieval_config:
  # ===== WEB SEARCH =====
  ENABLE_WEB_SEARCH: true
  WEB_SEARCH_TRUST_ENV: false
  WEB_SEARCH_CONCURRENT_REQUESTS: 1
  WEB_SEARCH_DOMAIN_FILTER_LIST: []
  WEB_SEARCH_RESULT_COUNT: 10
  # use LiteLLM's Perplexity-compatible API to proxy
  # search queries to backing providers like SearXNG:
  # https://docs.openwebui.com/features/chat-conversations/web-search/providers/perplexity_search#using-litellm-for-search
  # https://docs.litellm.ai/docs/search
  WEB_SEARCH_ENGINE: perplexity_search
  PERPLEXITY_SEARCH_API_URL: "{{ litellm_service_url }}/search/{{
    litellm_search_tools[0].search_tool_name }}"
  # litellm_api_key is fact set by task
  PERPLEXITY_API_KEY: "{{ litellm_api_key }}"
  BYPASS_WEB_SEARCH_EMBEDDING_AND_RETRIEVAL: false
  BYPASS_WEB_SEARCH_WEB_LOADER: false

  # ===== WEB LOADER =====
  WEB_LOADER_ENGINE: playwright
  WEB_LOADER_CONCURRENT_REQUESTS: 1
  PLAYWRIGHT_WS_URL: "{{ playwright_websocket_url }}"
  PLAYWRIGHT_TIMEOUT: 60000 # ms
