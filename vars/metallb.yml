# stable virtual IPv4 addresses reserved for specific LoadBalancer Services.
# they're assigned by each service's `metallb.io/loadBalancerIPs` annotation
# or by its `.spec.loadBalancerIP` field, although the latter is deprecated.

metallb_vips:
  # use subnet 192.168.4.0/24 which is not "on-link" for
  # clients, so they must route to pfSense. pfSense then
  # responds to ARP requests with advertised ECMP routes
  _manual:
    start: 192.168.4.222
    end: 192.168.4.240
  _auto:
    start: 192.168.4.242
    end: 192.168.4.250

  ingress: 192.168.4.222
  ingress-pt: 192.168.4.223 # SSL passthrough
  opensearch: 192.168.4.224
  postgresql: 192.168.4.225
  # Valkey creates a LoadBalancer Service
  # for each node, so reserve 6 IPs total
  valkey: 192.168.4.231 # ..192.168.4.236
  ollama: 192.168.4.226 # HTTP port 11434

metallb_namespace: metallb-system

metallb_secrets:
  speaker: metallb-memberlist

# https://github.com/bitnami/charts/tree/main/bitnami/metallb
metallb_chart_version: "6.4.22"
metallb_release_name: metallb

# https://github.com/bitnami/charts/tree/main/bitnami/metallb/values.yaml
metallb_chart_values:
  installCRDs: true

  controller:
    priorityClassName: "{{ priority_classes['critical'] }}"

    readinessProbe: &probe
      periodSeconds: 10
      timeoutSeconds: 3
      failureThreshold: 3
    livenessProbe: *probe

    metrics: &metrics
      enabled: true

      serviceMonitor:
        enabled: "{{ prometheus_crds_installed }}"
        labels:
          release: "{{ monitoring_release_name }}"

  speaker:
    # RKE2's Canal CNI doesn't use Calico's BGP feature:
    # it uses Flannel's VXLAN overlay for pod networking
    # and Calico for policies, so speaker is required to
    # advertise routes to the network via BGP
    enabled: true

    # native BGP implementation (as opposed to FRR)
    # is lighter weight and adequate for homelab:
    # https://metallb.io/concepts/bgp#frr-mode
    frr:
      enabled: false

    # "metallb-memberlist" Secret
    #  will be created by Ansible
    secretName: "{{ metallb_secrets['speaker'] }}"

    priorityClassName: "{{ priority_classes['critical'] }}"

    readinessProbe: *probe
    livenessProbe: *probe

    metrics: *metrics

  prometheusRule:
    enabled: "{{ prometheus_crds_installed }}"

# remember to install FRR package on pfSense
# and configure BGP local and remote ASNs as
# well as neighbor IPs for all cluster nodes

# helpful references:
# https://blog.perfectra1n.com/setting-up-metallb-in-bgp-mode-with-pfsense
# https://natarajmb.com/2025/02/kubernetes-services-over-bgp-with-metallb-and-pfsense

# required pfSense settings
# -------------------------
# Firewall/Rules/Floating -> Add Pass rule "Allow VIP from any" on
#                            Any interface in Any direction, using
#                            Any IPv4 protocol, from Any source to
#                            192.168.4.0/24 network. Set State type
#                            (Advanced Options) to Sloppy; ✅ Quick
#                            to apply the rule immediately on match
# FRR/Global/Routes -> Add "ALLOW-ALL" with description "Match any
#                      route", action "Permit", and sequence "100"
# FRR/BGP/Neighbors -> Use "ALLOW-ALL" route map for both inbound
#                      and outbound peer filtering
# FRR/BGP/Neighbors -> ✅ Per-neighbor Inbound Soft Reconfiguration
# FRR/BGP/Advanced  -> ✅ Disable requirement to apply incoming
#                         and outgoing filter to eBGP sessions

# the floating bi-directional quick-apply rule with "sloppy" state type is
# critical in our asymmetric network topology because VIPs are in different
# subnet to force traffic to pfSense so it can perform ECMP load balancing
# to cluster nodes; however, return traffic is on-link (in same subnet) to
# client, so pfSense never sees packets, and would thus reject subsequent,
# out-of-window ACKs from client had state type been "strict". with sloppy
# state handling, pfSense relaxes TCP validation: it doesn't bind state to
# specific interface, doesn't require full TCP handshake, tolerates missing
# reverse traffic

# pfSense diagnostic commands
# ---------------------------
# vtysh -c "show running-config"
# vtysh -c "show ip bgp"
# vtysh -c "show ip bgp summary"
# vtysh -c "show ip bgp neighbors 192.168.0.171 received-routes"
# vtysh -c "show ip route 192.168.4.222"
# vtysh -c 'conf t' -c 'router bgp 64512' -c 'address-family ipv4 unicast' \
#       -c 'maximum-paths 1' -c 'exit-address-family' -c 'end' -c 'write memory'
# vtysh -c "clear ip bgp * soft in"

# also see `netstat` commands:
# https://docs.netgate.com/pfsense/en/latest/routing/multipath.html

# client connectivity tests
# -------------------------
# nc -vz 192.168.4.222 80
# nc -vz 192.168.4.222 443

metallb_config_crs:
  - apiVersion: metallb.io/v1beta2
    kind: BGPPeer
    metadata:
      name: pfsense
    # https://metallb.io/apis#bgppeerspec
    spec:
      myASN: 64513 # cluster ASN
      peerASN: 64512 # pfSense ASN
      peerAddress: 192.168.0.1 # pfSense RID

  # https://metallb.io/configuration/_advanced_ipaddresspool_configuration
  - apiVersion: metallb.io/v1beta1
    kind: IPAddressPool
    metadata:
      name: manual-pool
    # https://metallb.io/apis#ipaddresspoolspec
    spec:
      addresses:
        - "{{ metallb_vips._manual.start }}-{{ metallb_vips._manual.end }}"
      autoAssign: false # service should define fixed IP in metallb_vips.*

  - apiVersion: metallb.io/v1beta1
    kind: IPAddressPool
    metadata:
      name: auto-pool
    spec:
      addresses:
        - "{{ metallb_vips._auto.start }}-{{ metallb_vips._auto.end }}"
      autoAssign: true

  # https://metallb.io/configuration/_advanced_bgp_configuration
  - apiVersion: metallb.io/v1beta1
    kind: BGPAdvertisement
    metadata:
      name: cluster-advert
    # https://metallb.io/apis#bgpadvertisementspec
    spec:
      ipAddressPools:
        - manual-pool
        - auto-pool
      aggregationLength: 32
