# restart Bash and load .bash_aliases
# in order to use my custom functions
exec /bin/bash <<'EOT'
set -o pipefail

TOKEN_DESC="Ansible session"
ADMIN_PASS="{{ rancher_admin_pass }}"
# .bash_aliases sources .rancher_api
. .bash_aliases || exit $?

if [ "$ADMIN_PASS" ]; then
  # if .rancher_api logged in with $ADMIN_PASS instead of
  # $BOOTSTRAP_PASS, ADMIN_PASS would have been unset, so
  # change the default password so user won`t be prompted
  echo >&2 "Changing default password..."
  rancher_api post "users?action=changepassword" @- <<JSON
{
  "currentPassword": "$BOOTSTRAP_PASS",
      "newPassword":     "$ADMIN_PASS"
}
JSON
  echo "_CHANGED_ admin password set."
fi

# when .rancher_api (templates/rancher/api.sh.j2)
# was sourced above, it would have exported both
# cluster and project ID env vars if registered
cluster="{{ rke_cluster_name }}"
id_var="${cluster^^}_ID"
cluster_id="${!id_var}"

get_state() {
  rancher_api get clusters/$cluster_id | \
    jq -r '.state // empty'
}
if [ ! "$cluster_id" ]; then
  # RKE cluster not imported yet
  # import using the Rancher API
  echo >&2 "Importing RKE cluster..."
  cluster_id=$(rancher_api post clusters @- <<'JSON' | jq -r '.id // empty'
{
  "import":      true,
  "type":        "cluster",
  "name":        "{{ rke_cluster_name }}",
  "description": "{{ rke_cluster_desc }}"
}
JSON
  )
  [ "$cluster_id" ] || {
    echo >&2 "Cluster import failed!"
    exit 1
  }
  echo "_CHANGED_ cluster imported."
  {
  echo -n "Waiting for cluster state to be pending.."
  until [ "$(get_state)" == pending ]; do
    echo -n .
    sleep 1
  done
  echo OK
  }   >&2
  export_variables
fi
# output ID for extraction
echo "CLUSTER=$cluster_id"

if [ "$(get_state)" != active ]; then
  # get cluster registration manifest URL so
  # it can be applied  on control plane node
  echo >&2 "Getting registration manifest URL..."
  reg_url=$(rancher_api get "clusters/$cluster_id/clusterregistrationtokens" | \
    \
    jq --arg baseUrl "$RANCHER_URL" -r '.data[] |
      select(.name == "default-token") |
        if (.manifestUrl // "") != "" then
          .manifestUrl
        elif (.token // "") != "" then
          "\($baseUrl)/v3/import/\(.token)_\(.clusterId).yaml"
        else empty
        end
      ')
  # output registration URL for extraction
  [ "$reg_url" ] && echo "REGISTER=$reg_url"
fi

# customize cluster appearance in the Rancher UI
echo >&2 "Applying Rancher UI customizations..."
rancher_api put "clusters/$cluster_id" @- <<'JSON' | \
  jq -cM '.annotations | with_entries(select(.key | startswith("ui.rancher")))' >&2
{
  "name": "{{ rke_cluster_name }}",
  "annotations": {
    "ui.rancher/badge-color":      "{{ ui_badge_color }}",
    "ui.rancher/badge-icon-text":  "{{ ui_badge_icon }}",
    "ui.rancher/badge-text":       "{{ ui_badge_text }}"
  }
}
JSON

# perform CLI login if not already
config="$HOME/.rancher/cli2.json"
[ -f $config ] && \
  [ "$(jq -r '.Servers[.CurrentServer].tokenKey // empty' $config)" ] || {

  # request a long-lived token
  echo >&2 "Requesting Rancher CLI token..."
  token=$(get_token "CLI token")
  id_var="${cluster^^}_DEFAULT_ID"

  echo >&2 "Performing Rancher CLI login..."
  rancher login "$RANCHER_URL" \
    --skip-verify      \
    --token   "$token" \
    --context "${!id_var}"

  echo "_CHANGED_ CLI logged in."
}
rancher_logout # delete $LOGIN_TOKEN
EOT
