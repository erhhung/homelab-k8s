# save rendered config as /var/lib/rancher/rke2/server/manifests/rke2-ingress-nginx-config.yaml
# on an RKE2 server node, after which rke2-server service on that node must be restarted:
# https://docs.rke2.io/helm#customizing-packaged-components-with-helmchartconfig
---
# https://docs.rke2.io/networking/networking_services#nginx-ingress-controller
# https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx/values.yaml
# https://github.com/rancher/rke2-charts/tree/main-source/packages/rke2-ingress-nginx/generated-changes/patch/values.yaml.patch

apiVersion: helm.cattle.io/v1
kind: HelmChartConfig
metadata:
  name: rke2-ingress-nginx
  namespace: kube-system
spec:
  valuesContent: |-
    controller:
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap
      config:
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#use-forwarded-headers
        use-forwarded-headers: "true"
        enable-real-ip: "true"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-read-timeout
        proxy-read-timeout: "600"
        proxy-send-timeout: "600"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-body-size
        proxy-body-size: 5m

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#client-body-buffer-size
        client-body-buffer-size: 256k
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-request-buffering
        proxy-request-buffering: "off"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-buffering
        proxy-buffering: "off"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-next-upstream
        proxy-next-upstream: "off"
        proxy-next-upstream-tries: "1"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#keep-alive
        keep-alive: "125"
        keep-alive-requests: "50"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#http-snippet
        http-snippet: |
          # set custom variable $request_origin = $http_origin
          # if Origin header provided, or else $scheme://$host
          # https://nginx.org/en/docs/http/ngx_http_map_module.html
          map $http_origin $request_origin {
            default "$scheme://$host";
            "~*" $http_origin;
          }

        # allow annotation group ServerSnippet (risk: Critical) in
        # my homelab environment, but likely bad security practice
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#annotations-risk-level
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations-risk
        annotations-risk-level: Critical

      # allow nginx.ingress.kubernetes.io/*-snippet
      # annotations, such as ones added by Keycloak
      allowSnippetAnnotations: true

      # https://kubernetes.github.io/ingress-nginx/user-guide/cli-arguments
      extraArgs:
        default-ssl-certificate: kube-system/{{ nginx_tls_secret }}

        # --enable-ssl-passthrough is required so that
        # the vCluster ingress controller can generate
        # and serve the proper SAN certificate for the
        # Kubernetes API server:
        # https://www.vcluster.com/docs/vcluster/manage/accessing-vcluster#expose-vcluster
        enable-ssl-passthrough: ""

        # https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services
        tcp-services-configmap: kube-system/{{ nginx_tcp_configmap }}
        udp-services-configmap: kube-system/{{ nginx_udp_configmap }}

      resources:
        requests:
          cpu: 25m
          memory: 256Mi

      service:
        # chart default value is enabled, but RKE2 patches
        # it to disabled--we want this LoadBalancer service
        # enabled so that MetalLB can assign it virtual IP
        enabled: true

        annotations:
          # replaces deprecated .spec.loadBalancerIP field
          metallb.universe.tf/loadBalancerIPs: "{{ metallb_vips['ingress'] }}"

        # prevent kube-proxy from re-spraying traffic to all
        # nodes since pfSense is already doing that via ECMP
        externalTrafficPolicy: Local
