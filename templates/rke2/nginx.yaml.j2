# save rendered config as /var/lib/rancher/rke2/server/manifests/rke2-ingress-nginx-config.yaml
# on an RKE2 server node, after which rke2-server service on that node must be restarted:
# https://docs.rke2.io/helm#customizing-packaged-components-with-helmchartconfig
---
# https://docs.rke2.io/networking/networking_services#nginx-ingress-controller
# https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx/values.yaml
# https://github.com/rancher/rke2-charts/tree/main-source/packages/rke2-ingress-nginx/generated-changes/patch/values.yaml.patch
# https://support.tools/rke2-ingress-nginx

apiVersion: helm.cattle.io/v1
kind: HelmChartConfig
metadata:
  name: rke2-ingress-nginx
  namespace: kube-system
spec:
  valuesContent: |-
    controller:
      ingressClass: {{ rke_ingress_class }}
      ingressClassResource:
        name: {{ rke_ingress_class }}
        enabled: true
        default: true
        controllerValue: k8s.io/ingress-{{ rke_ingress_class }}
      watchIngressWithoutClass: true
      ingressClassByName: true

      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap
      config:
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#log-format-upstream
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/log-format
        # https://nginx.org/en/docs/varindex.html
        log-format-upstream: >-
          {"time_ms": $msec, "remote_addr": "$remote_addr",
          "user_agent": "$http_user_agent", "host": "$http_host",
          "port": "$server_port", "method": "$request_method", "uri": "$request_uri",
          "protocol": "$server_protocol", "tls": "$ssl_protocol", "status": $status,
          "request_time": $request_time, "request_length": $request_length,
          "body_bytes_sent": $body_bytes_sent, "bytes_sent": $bytes_sent,
          "upstream_addr": "$upstream_addr",
          "upstream_connect_time": $upstream_connect_time,
          "upstream_response_time": $upstream_response_time}
        log-format-escape-json: "true"

        # log-format-upstream: >-
        #   $remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent
        #   "$http_referer" "$http_user_agent" $request_length $request_time
        #   [$proxy_upstream_name] $upstream_addr $upstream_status
        #   $upstream_response_time $upstream_bytes_received

        enable-real-ip: "true"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#use-proxy-protocol
        use-proxy-protocol: "false"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#use-forwarded-headers
        use-forwarded-headers: "true"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#compute-full-forwarded-for
        compute-full-forwarded-for: "true"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-real-ip-cidr
        proxy-real-ip-cidr: 192.168.0.0/16,100.64.0.0/10

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#enable-brotli
        enable-brotli: "true"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-read-timeout
        proxy-read-timeout: "600"
        proxy-send-timeout: "600"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-body-size
        proxy-body-size: 5m

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#client-body-buffer-size
        client-body-buffer-size: 256k
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-request-buffering
        proxy-request-buffering: "off"
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-buffering
        proxy-buffering: "off"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#proxy-next-upstream
        proxy-next-upstream: "off"
        proxy-next-upstream-tries: "1"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#keep-alive
        keep-alive: "125"
        keep-alive-requests: "50"

        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#http-snippet
        http-snippet: |
          # set custom variable $request_origin = $http_origin
          # if Origin header provided, or else $scheme://$host
          # https://nginx.org/en/docs/http/ngx_http_map_module.html
          map $http_origin $request_origin {
            default "$scheme://$host";
            "~*" $http_origin;
          }

        # allow annotation group ServerSnippet (risk: Critical) in
        # my homelab environment, but likely bad security practice
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap#annotations-risk-level
        # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations-risk
        annotations-risk-level: Critical

      # allow nginx.ingress.kubernetes.io/*-snippet
      # annotations, such as ones added by Keycloak
      allowSnippetAnnotations: true

      # https://kubernetes.github.io/ingress-nginx/user-guide/cli-arguments
      extraArgs:
        default-ssl-certificate: kube-system/{{ nginx_tls_secret }}

      priorityClassName: {{ priority_classes['critical'] }}

      resources:
        requests:
          cpu: 25m
          memory: 256Mi

      hostPort:
        enabled: false
      hostNetwork: false
      dnsPolicy: ClusterFirst

      service:
        # chart default value is enabled, but RKE2 patched
        # it to disabled--we want the LoadBalancer service
        # enabled so that MetalLB can assign it virtual IP
        enabled: true

        enableHttp: true
        enableHttps: true

        annotations:
          # replaces to-be-deprecated .spec.loadBalancerIP field
          metallb.io/loadBalancerIPs: "{{ metallb_vips['ingress'] }}"

        # prevent kube-proxy from re-spraying traffic to all
        # nodes since pfSense is already doing that via ECMP
        externalTrafficPolicy: Local

    # additional TCP/UDP ports to expose
    # on external service and Nginx pods
    tcp: {{ nginx_tcp_services }}
    udp: {{ nginx_udp_services }}
