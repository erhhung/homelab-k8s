#!/usr/bin/env bash
set -eo pipefail

# this Bash script uses curl to configure
# GitLab using same HTML form submissions
# and REST API calls as the web UI. tasks
# performed include:
#
# 1. add user "erhhung" besides root account
# 2. set new user password and user settings
# 3. create "Homelab" group owned by Erhhung
# 4. dismiss new user pop-ups and callouts
# 5. add Erhhung's SSH and GPG public keys
# 6. set app settings defined in vars file
# 7. add integrations defined in vars file
# 8. set  CI/CD vars  defined in vars file
# 9. register GitLab Runner and emit token
#
# pass the following variables:
#   site_base
#   system_time_zone
#   gitlab_root_pass
#   gitlab_user_pass
#   user_erhhung.*
#   erhhung_ssh_pub_key
#   erhhung_gpg_pub_key
#   gitlab_user_callouts[]
#   gitlab_user_prefs.*
#   gitlab_user_pins.*
#   gitlab_app_settings.*
#   gitlab_integrations.*
#   gitlab_cicd_vars.*
#   gitlab_runner.*

GITLAB_URL="{{ site_base }}"
TEMP_DIR="/tmp/gitlab"
mkdir -p "$TEMP_DIR"

    AUTH_USER="$TEMP_DIR/auth_user"
   COOKIE_JAR="$TEMP_DIR/cookie.jar"
 REFERER_HTML="$TEMP_DIR/referer.html"
RESPONSE_HTML="$TEMP_DIR/response.html"
RESPONSE_JSON="$TEMP_DIR/response.json"
  RUNNER_JSON="$TEMP_DIR/runner.json"

AUTH_ARGS=(
  -b "$COOKIE_JAR"
  -c "$COOKIE_JAR"
)
HTML_ARGS=(
  "${AUTH_ARGS[@]}"
  -H 'Accept: text/html'
  -o "$RESPONSE_HTML"
  -w '%{http_code}'
)
JSON_ARGS=(
  "${AUTH_ARGS[@]}"
  -H       'Accept: application/json'
  -H 'Content-Type: application/json'
  -o "$RESPONSE_JSON"
  -w '%{http_code}'
)

# get CSRF token for page given its URL
# csrf_token <page-url>
csrf_token() {
  local regex='name="(csrf-token|authenticity_token)" (content|value)="([^"]+)'
  curl -s "$1" "${AUTH_ARGS[@]}" | tee "$REFERER_HTML" | \
    sed -En 's/^.+'"$regex"'.+$/\3/p' | head -1
}

# get CSRF header for page given its URL
# (uses token given if arg is not a URL)
# csrf_header <page-url-or-csrf-token>
csrf_header() {
  local token="$1"
  [[ "$1" == *://* ]]   && \
    token=$(csrf_token "$1")
  printf -- "X-CSRF-Token: %s" "$token"
}

# print function name and args to stderr
_func_call() {
  echo >&2 " FUNCTION: ${FUNCNAME[1]}" "$*"
}

# output command (given as $@) to stderr
# and execute, piping in heredoc, if any
# run <command> [args...] [<<EOT...EOT]
run() {
  local arg args=()
  for arg in "$@"; do
    if [[ "$arg" =~ [[]|[]]|[\<\>\{\}\`\*\#\$\^\&\?\|\\\;] ]]; then
      args+=("'${arg//\'/\'\"\'\"\'}'")
    elif [[ "$arg" == *\'* && \
            "$arg" != *\"* ]]; then
      args+=("\"$arg\"")
    elif [[ "$arg" == *\"* && \
            "$arg" != *\'* ]]; then
      args+=("'$arg'")
    elif [[ "$arg" == *\"* && \
            "$arg" == *\'* ]]; then
      args+=("\"${arg//\"/\\\"}\"")
    elif [[ "$arg" == *\ * ]]; then
      args+=("\"$arg\"")
    else
      args+=("$arg")
    fi
  done

  local stdin
  if read -t 0; then
    stdin="$(cat -)"
  fi
  printf >&2 "EXECUTING:"
  printf >&2 " %s" "${args[@]}"
  [ "$stdin" ] && printf >&2 " <<'EOT'\n%s\nEOT" "$stdin"
  printf >&2 "\n"

  if [ "$stdin" ]; then # pipe in heredoc
    eval "echo \"\$stdin\" | ${args[*]}"
  else
    eval "${args[*]}"
  fi
}

root_login() {
  gitlab_login root '{{ gitlab_root_pass }}'
}
erhhung_login() {
  gitlab_login {{ user_erhhung.username }} \
              '{{ gitlab_user_pass }}'
}

# clear cookie jar and get new session credentials
# gitlab_login <user> <password>
gitlab_login() {
  _func_call "$@"
  rm -f "$AUTH_USER" "$COOKIE_JAR"

  local page_url user="$1" pass="$2"
  page_url="$GITLAB_URL/users/sign_in"
  local status=$(run curl -s "$page_url"   \
    -H "$(csrf_header        "$page_url")" \
    "${HTML_ARGS[@]}"      \
    -d "user[login]=$user" \
    -d "user[password]=$pass")

  printf "$status"
  [ "$status" == 302 ] || return
  printf "$user" > "$AUTH_USER"
}

# create primary user besides the root account
# (session will be switched to the new user if
# successful)
user_erhhung() {
  _func_call "$@"

  local user='{{ user_erhhung.username }}'
  local page_url="$GITLAB_URL/admin/users"
  local user_url="$page_url/$user"

  local status="$(run curl -s "$user_url" "${HTML_ARGS[@]}")"
  printf "$status,"
  [ "$status" == 404 ] || {
    erhhung_login
    return $?
  }

  local args=(
    -d "user[username]=$user"
    -d 'user[name]={{  user_erhhung.fullname }}'
    -d 'user[email]={{ user_erhhung.email }}'
    -d 'user[can_create_group]=1'
     # regular|admin (IMPORTANT: admin user cannot be
     # the target of a placeholder user reassignment)
    -d 'user[access_level]=regular'
    -d 'user[external]=0'
    -d 'user[credit_card_validation_attributes][credit_card_validated_at]=1'
  )
  local token="$(csrf_token "$page_url/new")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token" \
    "${args[@]}"

  printf ','
  token="$(csrf_token "$page_url")"
  run curl -s         "$user_url/trust" \
    "${HTML_ARGS[@]}" \
    -d '_method=put'  \
    -d "authenticity_token=$token"

  printf ',['
  set_password "$user" '{{ gitlab_user_pass }}'
  printf '],'
  erhhung_login
}

# set_password <user> <password>
# requires root user credentials, but
# will be switched to user afterwards
set_password() {
  _func_call "$@"

  local page_url token user="$1" pass="$2"
  page_url="$GITLAB_URL/admin/users/$user"
  token="$(csrf_token "$page_url/edit")"
  run curl -s         "$page_url" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' \
    -d "authenticity_token=$token"  \
    -d 'user[password]=t3MPA$$w0RD' \
    -d 'user[password_confirmation]=t3MPA$$w0RD'

  printf ','
  gitlab_login "$user" 't3MPA$$w0RD'
  printf ','

  page_url="$GITLAB_URL/-/user_settings/password"
  token="$(csrf_token "$page_url/new")"
  run curl -s         "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token"  \
    -d 'user[password]=t3MPA$$w0RD' \
    -d "user[new_password]=$pass"   \
    -d "user[password_confirmation]=$pass"
}

# use Erhhung's credentials to
# create group to become owner
group_homelab() {
  _func_call "$@"

  local group_id group='homelab'
  local group_url="$GITLAB_URL/$group"

  local status="$(run curl -s "$group_url" "${HTML_ARGS[@]}")"
  printf "$status"
  [ "$status" == 404 ] || return 0
  printf ','

  local args=(
     # top-level group
    -F 'group[parent_id]='
    -F 'group[name]=Homelab'
    -F 'group[path]=homelab'
    -F "group[description]=Erhhung's homelab projects"
     # image should be 192px square
    -F 'group[avatar]=@{{ playbook_dir }}/images/homelab.png;type=image/png'
     # 0=Private 10=Internal 20=Public
    -F 'group[visibility_level]=20'
     # for company/team or "just me"
    -F 'group[setup_for_company]=true'
     # basics|move_repository|code_storage|exploring|ci|other
    -F 'group[jobs_to_be_done]=ci'
     # invite members as developers
    -F 'group[emails][]='
    -F 'group[lfs_enabled]=1'
    -F 'group[request_access_enabled]=1'
     # 0=No One 2=Developers 4=Owners
     # 1=Maintainers 3=Administrators
    -F 'group[project_creation_level]=2'
     # 0=Owners 1=Maintainers
    -F 'group[subgroup_creation_level]=1'
    -F 'group[require_two_factor_authentication]=0'
    -F 'group[runner_registration_enabled]=1'
  )
  local page_url="$GITLAB_URL/groups"
  local token="$(csrf_token "$page_url/new")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -F "authenticity_token=$token" \
    "${args[@]}"

  printf ','
  run curl -s "$group_url" "${HTML_ARGS[@]}"
  group_id="$(sed -En 's/Group ID: ([0-9]+)/\1/p' "$RESPONSE_HTML")"
  echo >&2 "group_id: $group_id"

  printf ','
  page_url="$GITLAB_URL/-/users/group_callouts"
  run curl -s          "$page_url"   \
    -H "$(csrf_header "$group_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "feature_name": "invite_members_banner",
  "group_id":     "$group_id"
}
EOT
}

# requires admin user credentials
dismiss_popups() {
  _func_call "$@"

  local features=(
{% for feat in gitlab_user_callouts %}
    {{ feat }}
{% endfor %}
  )
  local feat once
  for feat in "${features[@]}"; do
    [ "$once" ] && printf ','
    once=1

    run curl -s         "$GITLAB_URL/-/users/callouts" \
      -H "$(csrf_header "$GITLAB_URL/")" \
      "${JSON_ARGS[@]}" -d '{"feature_name": "'$feat'"}'
  done
}

user_settings() {
  _func_call "$@"

  local page_url="$GITLAB_URL/-/user_settings/profile"
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' \
    -d "authenticity_token=$token" \
    -d 'user[timezone]={{ system_time_zone }}'  \
    -d 'user[user_detail_organization]=Homelab' \
    -d 'user[achievements_enabled]=1'
}

user_prefs() {
  _func_call "$@"

  local args=(
{% for pref, value in gitlab_user_prefs.items() %}
    -d '{{ pref }}={{ value }}'
{% endfor %}
  )
  local page_url="$GITLAB_URL/-/profile/preferences"
  run curl -s         "$page_url"   \
    -H "$(csrf_header "$page_url")" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' "${args[@]}"
}

user_pins() {
  _func_call "$@"

  local panels=()
{% for panel, menus in gitlab_user_pins.items() %}
  panels+=({{ panel }})
  local {{ panel }}_json='{{ {
    'panel':         panel,
    'menu_item_ids': menus,
  } | to_json(separators=[',',':']) }}'
{% endfor %}

  local panel once
  for panel in "${panels[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n json="${panel}_json"
    run curl -s -X PUT  "$GITLAB_URL/-/users/pins" \
      -H "$(csrf_header "$GITLAB_URL/homelab")" \
      "${JSON_ARGS[@]}" -d "$json"
  done
}

# remember to add to ~/.ssh/config:
# Host gitlab.fourteeners.local
#   IdentityFile ~/.ssh/erhhung
#   User git

add_ssh_key() {
  _func_call "$@"

  local url_path="-/user_settings/ssh_keys"
  local id page_url="$GITLAB_URL/$url_path"
  run curl -s "$page_url" "${HTML_ARGS[@]}"

  id="$(sed -En 's|^.*href="/'"$url_path"'/([0-9]+)".*$|\1|p' \
             "$RESPONSE_HTML" | sort -nr | head -1)"
  [ "$id" ] && return
  printf ','

  # key[key] value must be URL-encoded
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token" \
    -d 'key[key]={{ erhhung_ssh_pub_key | urlencode }}' \
    -d 'key[title]={{ user_erhhung.username }}' \
    -d 'key[usage_type]=auth_and_signing' \
    -d 'key[expires_at]='
}

add_gpg_key() {
  _func_call "$@"

  local url_path="-/user_settings/gpg_keys"
  local id page_url="$GITLAB_URL/$url_path"
  run curl -s "$page_url" "${HTML_ARGS[@]}"

  id="$(sed -En 's|^.*href="/'"$url_path"'/([0-9]+)".*$|\1|p' \
             "$RESPONSE_HTML" | sort -nr | head -1)"
  [ "$id" ] && return
  printf ','

  # gpg_key[key] value must be URL-encoded
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token" \
    -d 'gpg_key[key]={{ erhhung_gpg_pub_key | urlencode }}'
}

# requires root user credentials
app_settings() {
  _func_call "$@"

  local once url_base section sections=()
{% for name, section in gitlab_app_settings.items() %}
  sections+=({{ name }})
  local {{ name }}_args=(
{% for key, setting in section.items() %}
    -d '{{ key }}={{ setting.value }}'
{% endfor %}
  )
{% endfor %}
  url_base="$GITLAB_URL/admin/application_settings"
  for section in "${sections[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n args="${section}_args"
    local page_url="$url_base/$section"
    local token="$(csrf_token "$page_url")"
    run curl -s               "$page_url" \
      "${HTML_ARGS[@]}"  \
      -d '_method=patch' \
      -d "authenticity_token=$token" \
      "${args[@]}"
  done
}

# requires root user credentials
integrations() {
  _func_call "$@"

  local once url_base service services=()
{% for name, service in gitlab_integrations.items() %}
  services+=({{ name }})
  local {{ name }}_args=(
{% for setting, value in service.items() %}
    -d '{{ setting }}={{ value }}'
{% endfor %}
  )
{% endfor %}
  url_base="$GITLAB_URL/admin/application_settings/integrations"
  for service in "${services[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n args="${service}_args"
    local page_url="$url_base/$service"
    local token="$(csrf_token "$page_url/edit")"
    run curl -s               "$page_url" \
      "${HTML_ARGS[@]}"  \
      -d '_method=patch' \
      -d "authenticity_token=$token" \
      "${args[@]}"
  done
}

cicd_vars() {
  _func_call "$@"

  local page_url url_base="$GITLAB_URL/admin"
  page_url="$url_base/application_settings/ci_cd"
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "getVariables",
  "query": "query getVariables($after: String, $before: String, $first: Int, $last: Int, $sort: CiVariableSort = KEY_ASC) {ciVariables(after: $after before: $before first: $first last: $last sort: $sort) {nodes {...BaseCiVariable ...BaseCiInstanceVariable}}} fragment BaseCiVariable on CiVariable {id key value variableType} fragment BaseCiInstanceVariable on CiInstanceVariable {description protected masked raw}"
}
EOT
  local existing="$(jq '[.data.ciVariables.nodes[] | {
    (.key): .id | capture("/(?<x>\\d+)$").x | tonumber
    }] | add' "$RESPONSE_JSON")"

  printf ','
  run curl -sX PATCH  "$url_base/ci/variables" \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "variables_attributes": [
{% for var in gitlab_cicd_vars | ansible.builtin.dict2items(value_name='attrs') %}
    {
      "key": "{{ var.key }}",
      "variable_type": "env_var",
      "typename": "CiInstanceVariable",
{%   for attr, value in var.attrs.items() %}
{%     set value = value | to_json | replace('$','\$') %}
      "{{ attr }}": {{ value }},
{%     if attr == 'value' and 'secret_value' not in var.attrs %}
      "secret_value": {{ value }},
{%     endif %}
{%   endfor %}
      "id": $(jq '.{{ var.key }} // null' <<< "$existing")
    }
{{- '\n' if loop.last else ',\n' -}}
{% endfor %}
  ]
}
EOT
}

# requires root user credentials
register_runner() {
  _func_call "$@"
  rm -f "$RUNNER_JSON"

  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$GITLAB_URL/admin/runners")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "getRunners",
  "query": "query getRunners() {runners {nodes {id description creationState}}}"
}
EOT
  local exists="$(jq -r '.data.runners.nodes | map(
    select(.description == "{{ gitlab_runner.name }}")
    ) | length' "$RESPONSE_JSON")"
  [ "$exists" == 0 ] || return 0

  printf ','
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$GITLAB_URL/admin/runners/new")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "runnerCreate",
  "variables": {
    "input": {
      "runnerType": "INSTANCE_TYPE",
      "description": "{{ gitlab_runner.name }}",
      "tagList": {{ gitlab_runner.tags | to_json(separators=[',',':']) }},
      "locked": false,
      "paused": false,
      "runUntagged": true,
      "accessLevel": "NOT_PROTECTED",
      "maximumTimeout": {{ gitlab_runner.max_timeout }},
      "maintenanceNote": ""
    }
  },
  "query": "mutation runnerCreate($input: RunnerCreateInput!) {runnerCreate(input: $input) {runner {id ephemeralRegisterUrl} errors}}"
}
EOT
  eval "$(jq -r '.data.runnerCreate.runner | "
    local reg_url=\"\(.ephemeralRegisterUrl)\"
    local runner_id=\"\(.id)\"
    "' "$RESPONSE_JSON")"
  echo >&2 "runner_id: $runner_id"
  echo >&2 "  reg_url: $reg_url"

  printf ','
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$reg_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "operationName": "getRunnerForRegistration",
  "variables": {
    "id": "$runner_id"
  },
  "query": "query getRunnerForRegistration(\$id: CiRunnerID!) {runner(id: \$id) {id description ephemeralAuthenticationToken creationState}}"
}
EOT
  # function is being called from subshell,
  # so export runner info to temp JSON file
  jq '.data.runner | {
    runner: {
      id,
      name:  .description,
      token: .ephemeralAuthenticationToken
    }
  }' "$RESPONSE_JSON" > "$RUNNER_JSON"
}

echo "‖        Login: $(root_login)"
echo "‖      Erhhung: $(user_erhhung)"
echo "‖      ‖    Group: $(group_homelab)"
echo "‖      ‖   Popups: $(dismiss_popups)"
echo "‖      ‖ Settings: $(user_settings),$(user_prefs),[$(user_pins)]"
echo "‖      ‖ Pub Keys: $(add_ssh_key),$(add_gpg_key)"
echo "‖        Login: $(root_login)"
echo "‖       Popups: $(dismiss_popups)"
echo "‖     Settings: $(user_settings),$(user_prefs),[$(app_settings)]"
echo "‖ Integrations: $(integrations)"
echo "‖   CI/CD Vars: $(cicd_vars)"
echo "‖       Runner: $(register_runner)"
[ -f "$RUNNER_JSON" ] || exit 0

eval "$(jq -r '.runner | "
  runner_id=\"\(.id)\"
  runner_name=\"\(.name)\"
  runner_token=\"\(.token)\"
  "' < "$RUNNER_JSON")"
echo "$runner_name ID: $runner_id"
echo  "RUNNER_TOKEN=$runner_token"
