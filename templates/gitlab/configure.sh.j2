#!/usr/bin/env bash
set -eo pipefail

# this Bash script uses curl to configure
# GitLab using same HTML form submissions
# and REST API calls as the web UI. tasks
# performed include:
#
#  1. add user "erhhung" besides root account
#  2. set new user password and user settings
#  3. create "Homelab" group owned by Erhhung
#  4. set group settings defined in vars file
#  5. dismiss new user pop-ups and callouts
#  6. add Erhhung's SSH and GPG public keys
#  7. set app settings defined in vars file
#  8. add integrations defined in vars file
#  9. set  CI/CD vars  defined in vars file
# 10. generate  admin personal access token
# 11. register GitLab Runner and emit token
#
# pass the following variables:
#   site_base
#   system_time_zone
#   gitlab_root_pass
#   gitlab_user_pass
#   user_erhhung.*
#   erhhung_ssh_pub_key
#   erhhung_gpg_pub_key
#   gitlab_user_callouts[]
#   gitlab_user_prefs.*
#   gitlab_user_pins.*
#   gitlab_group_settings.*
#   gitlab_app_settings.*
#   gitlab_integrations.*
#   gitlab_cicd_vars.*
#   gitlab_runner.*

GITLAB_URL="{{ site_base }}"
TEMP_DIR="/tmp/gitlab"
mkdir -p "$TEMP_DIR"

    AUTH_USER="$TEMP_DIR/auth_user"
   COOKIE_JAR="$TEMP_DIR/cookie.jar"
 REFERER_HTML="$TEMP_DIR/referer.html"
RESPONSE_HTML="$TEMP_DIR/response.html"
RESPONSE_JSON="$TEMP_DIR/response.json"
     PAT_JSON="$TEMP_DIR/pat.json"
  RUNNER_JSON="$TEMP_DIR/runner.json"

# sleep delay before run command
# to throttle requests to server
RUN_DELAY="0.5"

AUTH_ARGS=(
  -b "$COOKIE_JAR"
  -c "$COOKIE_JAR"
)
RETRY_ARGS=(
  --retry       2
  --retry-delay 2
)
HTML_ARGS=(
  "${AUTH_ARGS[@]}"
  -H 'Accept: text/html'
  -o "$RESPONSE_HTML"
  -w '%{http_code}'
  "${RETRY_ARGS[@]}"
)
JSON_ARGS=(
  "${AUTH_ARGS[@]}"
  -H       'Accept: application/json'
  -H 'Content-Type: application/json'
  -o "$RESPONSE_JSON"
  -w '%{http_code}'
  "${RETRY_ARGS[@]}"
)
rm -f $AUTH_USER $COOKIE_JAR

# get CSRF token for page given its URL
# csrf_token <page-url>
csrf_token() {
  local regex='name="(csrf-token|authenticity_token)" (content|value)="([^"]+)'
  curl -s "$1" "${AUTH_ARGS[@]}" | tee "$REFERER_HTML" | \
    sed -En 's/^.+'"$regex"'.+$/\3/p' | head -1
}

# get CSRF header for page given its URL
# (uses token given if arg is not a URL)
# csrf_header <page-url-or-csrf-token>
csrf_header() {
  local token="$1"
  [[ "$1" == *://* ]]   && \
    token=$(csrf_token "$1")
  printf -- "X-CSRF-Token: %s" "$token"
}

# print function name and args to stderr
_func_call() {
  local args=("$@")
  [ -f $AUTH_USER ] && args+=("[$(< $AUTH_USER)]")
  echo >&2 " FUNCTION: ${FUNCNAME[1]}" "${args[*]}"
}

# output command (given as $@) to stderr
# and execute, piping in heredoc, if any
# run <command> [args...] [<<EOT...EOT]
run() {
  # Bash only compares ints
  [ "$RUN_DELAY"      ] && \
  [ "$RUN_DELAY" != 0 ] && \
    sleep $RUN_DELAY

  local arg args=()
  for arg in "$@"; do
    if [[ "$arg" =~ [[]|[]]|[\<\>\{\}\`\*\#\$\^\&\?\|\\\;] ]]; then
      args+=("'${arg//\'/\'\"\'\"\'}'")
    elif [[ "$arg" == *\'* && \
            "$arg" != *\"* ]]; then
      args+=("\"$arg\"")
    elif [[ "$arg" == *\"* && \
            "$arg" != *\'* ]]; then
      args+=("'$arg'")
    elif [[ "$arg" == *\"* && \
            "$arg" == *\'* ]]; then
      args+=("\"${arg//\"/\\\"}\"")
    elif [[ "$arg" == *\ * ]]; then
      args+=("\"$arg\"")
    else
      args+=("$arg")
    fi
  done

  local stdin
  if read -t 0; then
    stdin="$(cat -)"
  fi
  printf >&2 "EXECUTING:"
  printf >&2 " %s" "${args[@]}"
  [ "$stdin" ] && printf >&2 " <<'EOT'\n%s\nEOT" "$stdin"
  printf >&2 "\n"

  local status=$(
    if [ "$stdin" ]; then # pipe in heredoc
      eval "echo \"\$stdin\" | ${args[*]}"
    else
      eval "${args[*]}"
    fi
  )
  printf "$status"
  # fail if status isn't success
  [[ "$status" =~ 200|201|302 ]]
}

root_login() {
  gitlab_login root '{{ gitlab_root_pass }}'
}
erhhung_login() {
  gitlab_login {{ user_erhhung.username }} \
              '{{ gitlab_user_pass }}'
}

# clear cookie jar and get new session credentials
# gitlab_login <user> <password>
gitlab_login() {
  _func_call "$@"
  rm -f $AUTH_USER $COOKIE_JAR

  local page_url user="$1" pass="$2"
  page_url="$GITLAB_URL/users/sign_in"
  run curl -s          "$page_url"   \
    -H "$(csrf_header  "$page_url")" \
    "${HTML_ARGS[@]}"      \
    -d "user[login]=$user" \
    -d "user[password]=$pass"

  printf "$user" > $AUTH_USER
}

# create primary user besides the root account
# (session will be switched to the new user if
# successful)
user_erhhung() {
  _func_call "$@"

  local user='{{ user_erhhung.username }}'
  local page_url="$GITLAB_URL/admin/users"
  local user_url="$page_url/$user"
  local args token

  local status="$(run curl -s "$user_url" "${HTML_ARGS[@]}")"
  printf "$status,"

  [ "$status" == 404 ] && {
    args=(
      -d "user[username]=$user"
      -d 'user[name]={{  user_erhhung.fullname }}'
      -d 'user[email]={{ user_erhhung.email }}'
      -d 'user[can_create_group]=1'
      # regular|admin (IMPORTANT: admin user cannot be
      # the target of a placeholder user reassignment)
      -d 'user[access_level]=regular'
      -d 'user[external]=0'
      -d 'user[credit_card_validation_attributes][credit_card_validated_at]=1'
    )
    token="$(csrf_token "$page_url/new")"
    run curl -s         "$page_url" \
      "${HTML_ARGS[@]}" \
      -d "authenticity_token=$token" \
      "${args[@]}"
    printf ','
  }

  token="$(csrf_token "$page_url")"
  run curl -s         "$user_url/trust" \
    "${HTML_ARGS[@]}" \
    -d '_method=put'  \
    -d "authenticity_token=$token"

  printf ',['
  set_password "$user" '{{ gitlab_user_pass }}'
  printf '],'
  erhhung_login
}

# set_password <user> <password>
# requires root user credentials, but
# will be switched to user afterwards
set_password() {
  _func_call "$@"

  local page_url token user="$1" pass="$2"
  page_url="$GITLAB_URL/admin/users/$user"
  token="$(csrf_token "$page_url/edit")"
  run curl -s         "$page_url" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' \
    -d "authenticity_token=$token"  \
    -d 'user[password]=t3MPA$$w0RD' \
    -d 'user[password_confirmation]=t3MPA$$w0RD'

  printf ','
  gitlab_login "$user" 't3MPA$$w0RD'
  printf ','

  page_url="$GITLAB_URL/-/user_settings/password"
  token="$(csrf_token "$page_url/new")"
  run curl -s         "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token"  \
    -d 'user[password]=t3MPA$$w0RD' \
    -d "user[new_password]=$pass"   \
    -d "user[password_confirmation]=$pass"
}

# use Erhhung's credentials to
# create group to become owner
group_homelab() {
  _func_call "$@"

  local group_id group='homelab'
  local group_url="$GITLAB_URL/$group"
  local args token page_url

  local status="$(run curl -s "$group_url" "${HTML_ARGS[@]}")"
  printf "$status"

  [ "$status" == 404 ] && {
    printf ','
    args=(
      # top-level group
      -F 'group[parent_id]='
      -F 'group[name]=Homelab'
      -F 'group[path]=homelab'
      -F "group[description]=Erhhung's homelab projects"
      # image should be 192px square
      -F 'group[avatar]=@{{ playbook_dir }}/images/homelab.png;type=image/png'
      # 0=Private 10=Internal 20=Public
      -F 'group[visibility_level]=20'
      # for company/team or "just me"
      -F 'group[setup_for_company]=true'
      # basics|move_repository|code_storage|exploring|ci|other
      -F 'group[jobs_to_be_done]=ci'
      # invite members as developers
      -F 'group[emails][]='
      -F 'group[lfs_enabled]=1'
      -F 'group[request_access_enabled]=1'
      # 0=No One 2=Developers 4=Owners
      # 1=Maintainers 3=Administrators
      -F 'group[project_creation_level]=2'
      # 0=Owners 1=Maintainers
      -F 'group[subgroup_creation_level]=1'
      -F 'group[require_two_factor_authentication]=0'
      -F 'group[runner_registration_enabled]=1'
    )
    page_url="$GITLAB_URL/groups"
    token="$(csrf_token "$page_url/new")"
    run curl -s         "$page_url" \
      "${HTML_ARGS[@]}" \
      -F "authenticity_token=$token" \
      "${args[@]}"

    printf ','
    run curl -s "$group_url" "${HTML_ARGS[@]}"
  }

  group_id="$(sed -En 's/Group ID: ([0-9]+)/\1/p' "$RESPONSE_HTML")"
  echo >&2 "group_id: ${group_id:-N/A}"
  [ "$group_id" ] || return

  printf ','
  page_url="$GITLAB_URL/-/users/group_callouts"
  run curl -s          "$page_url"   \
    -H "$(csrf_header "$group_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "feature_name": "invite_members_banner",
  "group_id":     "$group_id"
}
EOT
}

# use owner credentials
# group_settings <group>
group_settings() {
  _func_call "$@"

  local group=$1 groups=() section sections=()
{% for g_name, group in gitlab_group_settings.items() %}
  groups+=({{ g_name }})
{%   for s_name, section in group.items() %}
  sections+=({{ g_name }}:{{ s_name }})
{%     set name = g_name ~'_'~ s_name.replace('/','_') %}
  local {{ name }}_args=(
{%     for key, value in section.items() %}
    -d '{{ key }}={{ value }}'
{%     endfor %}
  )
{%   endfor %}
{% endfor %}
  local s_name once url_base page_url referer token
  url_base="$GITLAB_URL/groups/$group/-/settings"

  for section in "${sections[@]}"; do
    [[ "$section" == "$group:"* ]] || continue
    [ "$once" ] && printf ','
    once=1

    s_name="${section#*:}"
    page_url="$url_base/$s_name"
    referer="$url_base/${s_name%/*}"
    token="$(csrf_token "$referer")"
    local -n args="${group}_${s_name//\//_}_args"

    run curl -s "$page_url" \
      "${HTML_ARGS[@]}"  \
      -d '_method=patch' \
      -d "authenticity_token=$token" \
      "${args[@]}"
  done
}

# requires admin user credentials
dismiss_popups() {
  _func_call "$@"

  local features=(
{% for feat in gitlab_user_callouts %}
    {{ feat }}
{% endfor %}
  )
  local feat once
  for feat in "${features[@]}"; do
    [ "$once" ] && printf ','
    once=1

    run curl -s         "$GITLAB_URL/-/users/callouts" \
      -H "$(csrf_header "$GITLAB_URL/")" \
      "${JSON_ARGS[@]}" -d '{"feature_name": "'$feat'"}'
  done
}

user_settings() {
  _func_call "$@"

  local page_url="$GITLAB_URL/-/user_settings/profile"
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' \
    -d "authenticity_token=$token" \
    -d 'user[timezone]={{ system_time_zone }}'  \
    -d 'user[user_detail_organization]=Homelab' \
    -d 'user[achievements_enabled]=1'
}

user_prefs() {
  _func_call "$@"

  local args=(
{% for pref, value in gitlab_user_prefs.items() %}
    -d '{{ pref }}={{ value }}'
{% endfor %}
  )
  local page_url="$GITLAB_URL/-/profile/preferences"
  run curl -s         "$page_url"   \
    -H "$(csrf_header "$page_url")" \
    "${HTML_ARGS[@]}"  \
    -d '_method=patch' "${args[@]}"
}

user_pins() {
  _func_call "$@"

  local panels=()
{% for panel, menus in gitlab_user_pins.items() %}
  panels+=({{ panel }})
  local {{ panel }}_json='{{ {
    'panel':         panel,
    'menu_item_ids': menus,
  } | to_json(separators=[',',':']) }}'
{% endfor %}

  local panel once
  for panel in "${panels[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n json="${panel}_json"
    run curl -s -X PUT  "$GITLAB_URL/-/users/pins" \
      -H "$(csrf_header "$GITLAB_URL/homelab")" \
      "${JSON_ARGS[@]}" -d "$json"
  done
}

# remember to add to ~/.ssh/config:
# Host gitlab.fourteeners.local
#   IdentityFile ~/.ssh/erhhung
#   User git

add_ssh_key() {
  _func_call "$@"

  local url_path="-/user_settings/ssh_keys"
  local id page_url="$GITLAB_URL/$url_path"
  run curl -s "$page_url" "${HTML_ARGS[@]}"

  id="$(sed -En 's|^.*href="/'"$url_path"'/([0-9]+)".*$|\1|p' \
             "$RESPONSE_HTML" | sort -nr | head -1)"
  [ "$id" ] && return
  printf ','

  # key[key] value must be URL-encoded
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token" \
    -d 'key[key]={{ erhhung_ssh_pub_key | urlencode }}' \
    -d 'key[title]={{ user_erhhung.username }}' \
    -d 'key[usage_type]=auth_and_signing' \
    -d 'key[expires_at]='
}

add_gpg_key() {
  _func_call "$@"

  local url_path="-/user_settings/gpg_keys"
  local id page_url="$GITLAB_URL/$url_path"
  run curl -s "$page_url" "${HTML_ARGS[@]}"

  id="$(sed -En 's|^.*href="/'"$url_path"'/([0-9]+)".*$|\1|p' \
             "$RESPONSE_HTML" | sort -nr | head -1)"
  [ "$id" ] && return
  printf ','

  # gpg_key[key] value must be URL-encoded
  local token="$(csrf_token "$page_url")"
  run curl -s               "$page_url" \
    "${HTML_ARGS[@]}" \
    -d "authenticity_token=$token" \
    -d 'gpg_key[key]={{ erhhung_gpg_pub_key | urlencode }}'
}

# requires root user credentials
app_settings() {
  _func_call "$@"

  local once url_base section sections=()
{% for name, section in gitlab_app_settings.items() %}
  sections+=({{ name }})
  local {{ name }}_args=(
{% for key, setting in section.items() %}
    -d '{{ key }}={{ setting.value }}'
{% endfor %}
  )
{% endfor %}
  url_base="$GITLAB_URL/admin/application_settings"
  for section in "${sections[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n args="${section}_args"
    local page_url="$url_base/$section"
    local token="$(csrf_token "$page_url")"
    run curl -s               "$page_url" \
      "${HTML_ARGS[@]}"  \
      -d '_method=patch' \
      -d "authenticity_token=$token" \
      "${args[@]}"
  done
}

# requires root user credentials
integrations() {
  _func_call "$@"

  local once url_base service services=()
{% for name, service in gitlab_integrations.items() %}
  services+=({{ name }})
  local {{ name }}_args=(
{% for setting, value in service.items() %}
    -d '{{ setting }}={{ value }}'
{% endfor %}
  )
{% endfor %}
  url_base="$GITLAB_URL/admin/application_settings/integrations"
  for service in "${services[@]}"; do
    [ "$once" ] && printf ','
    once=1

    local -n args="${service}_args"
    local page_url="$url_base/$service"
    local token="$(csrf_token "$page_url/edit")"
    run curl -s               "$page_url" \
      "${HTML_ARGS[@]}"  \
      -d '_method=patch' \
      -d "authenticity_token=$token" \
      "${args[@]}"
  done
}

cicd_vars() {
  _func_call "$@"

  local page_url url_base="$GITLAB_URL/admin"
  page_url="$url_base/application_settings/ci_cd"
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "getVariables",
  "query": "query getVariables($after: String, $before: String, $first: Int, $last: Int, $sort: CiVariableSort = KEY_ASC) {ciVariables(after: $after before: $before first: $first last: $last sort: $sort) {nodes {...BaseCiVariable ...BaseCiInstanceVariable}}} fragment BaseCiVariable on CiVariable {id key value variableType} fragment BaseCiInstanceVariable on CiInstanceVariable {description protected masked raw}"
}
EOT
  local existing="$(jq '[.data.ciVariables.nodes[] | {
    (.key): .id | capture("/(?<x>\\d+)$").x | tonumber
    }] | add' $RESPONSE_JSON)"

  printf ','
  run curl -sX PATCH  "$url_base/ci/variables" \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "variables_attributes": [
{% for var in gitlab_cicd_vars | ansible.builtin.dict2items(value_name='attrs') %}
    {
      "key": "{{ var.key }}",
      "variable_type": "env_var",
      "typename": "CiInstanceVariable",
{%   for attr, value in var.attrs.items() %}
{%     set value = value | to_json | replace('$','\$') %}
      "{{ attr }}": {{ value }},
{%     if attr == 'value' and 'secret_value' not in var.attrs %}
      "secret_value": {{ value }},
{%     endif %}
{%   endfor %}
      "id": $(jq '.{{ var.key }} // null' <<< "$existing")
    }
{{- '\n' if loop.last else ',\n' -}}
{% endfor %}
  ]
}
EOT
}

admin_pat() {
  _func_call "$@"
  rm -f $PAT_JSON

  local api_url page_url exists scopes date expires
  api_url="$GITLAB_URL/api/v4/personal_access_tokens?search=admin&state=active"
  page_url="$GITLAB_URL/-/user_settings/personal_access_tokens"
  run curl -s          "$api_url"   \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}"

  exists=$(jq -r 'map(select(.name == "admin" and .active))
      | length' $RESPONSE_JSON)
  [ "$exists" -eq 0 ] || return 0

  # https://docs.gitlab.com/user/profile/personal_access_tokens#personal-access-token-scopes
  scopes="$(jo -a api write_repository manage_runner self_rotate admin_mode sudo)"
  date=$(command -v gdate || command -v date) # GNU `date` required
  expires=$($date -d "$($date +%Y-%m-01) +1 year -1 day" +%Y-%m-%d)

  printf ','
  run curl -s         "$page_url"   \
    -H "$(csrf_header "$page_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "name":        "admin",
  "scopes":      $scopes,
  "expires_at": "$expires"
}
EOT
  mv -f $RESPONSE_JSON $PAT_JSON
}

register_runner() {
  _func_call "$@"
  rm -f $RUNNER_JSON

  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$GITLAB_URL/admin/runners")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "getRunners",
  "query": "query getRunners() {runners {nodes {id description creationState}}}"
}
EOT
  local exists=$(jq -r '.data.runners.nodes | map(
    select(.description == "{{ gitlab_runner.name }}")
    ) | length' $RESPONSE_JSON)
  [ "$exists" -eq 0 ] || return 0

  printf ','
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$GITLAB_URL/admin/runners/new")" \
    "${JSON_ARGS[@]}" -d @- <<'EOT'
{
  "operationName": "runnerCreate",
  "variables": {
    "input": {
      "runnerType": "INSTANCE_TYPE",
      "description": "{{ gitlab_runner.name }}",
      "tagList": {{ gitlab_runner.tags | to_json(separators=[',',':']) }},
      "locked": false,
      "paused": false,
      "runUntagged": true,
      "accessLevel": "NOT_PROTECTED",
      "maximumTimeout": {{ gitlab_runner.max_timeout }},
      "maintenanceNote": ""
    }
  },
  "query": "mutation runnerCreate($input: RunnerCreateInput!) {runnerCreate(input: $input) {runner {id ephemeralRegisterUrl} errors}}"
}
EOT
  eval "$(jq -r '.data.runnerCreate.runner | "
    local reg_url=\"\(.ephemeralRegisterUrl)\"
    local runner_id=\"\(.id)\"
    "' $RESPONSE_JSON)"
  echo >&2 "runner_id: $runner_id"
  echo >&2 "  reg_url: $reg_url"

  printf ','
  run curl -s         "$GITLAB_URL/api/graphql" \
    -H "$(csrf_header "$reg_url")" \
    "${JSON_ARGS[@]}" -d @- <<EOT
{
  "operationName": "getRunnerForRegistration",
  "variables": {
    "id": "$runner_id"
  },
  "query": "query getRunnerForRegistration(\$id: CiRunnerID!) {runner(id: \$id) {id description ephemeralAuthenticationToken creationState}}"
}
EOT
  # function may be called from a subshell,
  # so export runner info to temp JSON file
  jq '.data.runner | {
    runner: {
      id,
      name:  .description,
      token: .ephemeralAuthenticationToken
    }
  }' $RESPONSE_JSON > $RUNNER_JSON
}

printf "‖        Login: ";     root_login;             echo
printf "‖      Erhhung: ";     user_erhhung;           echo
printf "‖      ‖    Group: ["; group_homelab;          printf "],["
                               group_settings homelab; echo     "]"
printf "‖      ‖   Popups: ";  dismiss_popups;         echo
printf "‖      ‖ Settings: ";  user_settings;          printf  ","
                               user_prefs;             printf  ",["
                               user_pins;              echo     "]"
printf "‖      ‖ Pub Keys: ";  add_ssh_key;            printf  ","
                               add_gpg_key;            echo
printf "‖        Login: ";     root_login;             echo
printf "‖       Popups: ";     dismiss_popups;         echo
printf "‖     Settings: ";     user_settings;          printf  ","
                               user_prefs;             printf  ",["
                               app_settings;           echo     "]"
printf "‖ Integrations: ";     integrations;           echo
printf "‖   CI/CD Vars: ";     cicd_vars;              echo
printf "‖    Admin PAT: ";     admin_pat;              echo
printf "‖       Runner: ";     register_runner;        echo

if [ -f $PAT_JSON ]; then
  echo "ADMIN_PAT=$(jq -r .token $PAT_JSON)"
  rm -f $PAT_JSON
fi
if [ -f $RUNNER_JSON ]; then
  eval "$(jq -r '.runner | "
    runner_id=\"\(.id)\"
    runner_name=\"\(.name)\"
    runner_token=\"\(.token)\"
    "' < $RUNNER_JSON)"
  echo "$runner_name ID: $runner_id"
  echo  "RUNNER_TOKEN=$runner_token"
  rm -f $RUNNER_JSON
fi
