# https://docs.flowiseai.com/
# https://docs.flowiseai.com/configuration
---
- name: Install Flowise on RKE cluster
  tags: install
  hosts: "{{ rke_control_plane_host }}"
  gather_facts: false
  vars_files:
    - vars/kubernetes.yml
    - vars/postgresql.yml
    - vars/valkey.yml
    - vars/storage.yml
    - vars/flowise.yml
  vars:
    # required kubernetes>=24.2 package only in user virtualenv
    ansible_python_interpreter: "{{ venv_python_interpreter }}"
    kubeconfig: "{{ rke_kubeconfig }}"
    secret_ns: "{{ flowise_namespace }}"
    create_ns: false
    release: "{{ flowise_release_name }}"
  pre_tasks:
    - name: Get the PostgreSQL image used
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_tasks_module.html
      ansible.builtin.include_tasks: tasks/postgresql/image.yml
      when: postgresql_image is not defined
  tasks:
    - name: Create Flowise encryption secret
      vars:
        secret_name: "{{ flowise_secrets['encryption'] }}"
        secret_data:
          encryption-key: "{{ flowise_encryption_key }}"
        create_ns: true
      ansible.builtin.include_tasks: tasks/k8s/secrets/generic.yml

    - name: Create Flowise credentials secret
      vars:
        secret_name: "{{ flowise_secrets['credentials'] }}"
        secret_data:
          postgresql-password: "{{ pgpool_pass }}"
          # valkey-password: "{{ valkey_pass }}"
      ansible.builtin.include_tasks: tasks/k8s/secrets/generic.yml

    # only to install PostgreSQL extensions
    - name: Create database superuser secret
      vars:
        secret_name: "{{ postgresql_secrets['superuser'] }}"
        cert_name: database-superuser
        days: 365
        sans:
          - "{{ postgresql_superuser }}"
          - "{{ postgresql_superuser }}@{{ homelab_domain }}"
      ansible.builtin.include_tasks: tasks/k8s/secrets/tls.step.yml

    # database-restricted PostgreSQL user
    - name: Create Flowise database secret
      vars:
        secret_name: "{{ flowise_secrets['database'] }}"
        cert_name: flowise-database
        days: 365
        sans:
          - "{{ flowise_db_user }}"
          - "{{ flowise_db_user }}@{{ homelab_domain }}"
      ansible.builtin.include_tasks: tasks/k8s/secrets/tls.step.yml

    - name: Create Flowise ingress secret
      vars:
        secret_name: "{{ flowise_secrets['ingress'] }}"
        cert_name: flowise-ingress
        sans: "{{ [flowise_fqdn] }}"
      ansible.builtin.include_tasks: tasks/k8s/secrets/tls.step.yml

    - name: Install Flowise Helm chart
      # https://docs.ansible.com/ansible/latest/collections/kubernetes/core/helm_module.html
      kubernetes.core.helm:
        kubeconfig: "{{ kubeconfig }}"
        # chart_repo_url: https://cowboysysop.github.io/charts
        # use modified chart in our forked repo on branch "flowise-redis-tls"
        # with support for TLS in wait-redis init containers as well as extra
        # init containers (requires helm-git plugin)
        chart_repo_url: git+https://github.com/erhhung/cowboysysop-charts@charts/flowise?ref=flowise-redis-tls
        chart_ref: flowise
        chart_version: "{{ flowise_chart_version }}"
        release_name: "{{ flowise_release_name }}"
        release_namespace: "{{ flowise_namespace }}"
        release_values: "{{ flowise_chart_values }}"
        history_max: "{{ helm_max_history }}"
        atomic: true
        wait: true
        wait_timeout: 10m0s # requires wait=true
      # pulling custom images from
      # Harbor could take a while
      timeout: 900
  any_errors_fatal: true

- name: Configure Flowise installation
  tags:
    - configure
    - documents
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/flowise.yml
    - vars/kubernetes.yml
    - vars/postgresql.yml
    - vars/qdrant.yml
    - vars/ollama.yml
  vars:
    api_base: https://{{ flowise_fqdn }}/api/v1
    doc_store_name: Accounts
  pre_tasks:
    - name: Wait until Flowise is ready
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.html
      ansible.builtin.uri:
        url: "{{ api_base }}/ping"
        return_content: true
      # https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html#retrying-a-task-until-a-condition-is-met
      register: site_check
      until: site_check.content == 'pong'
      retries: 20
      delay: 3
  tasks:
    - name: Authenticate as admin user
      ansible.builtin.uri:
        method: POST
        url: "{{ api_base }}/auth/login"
        body_format: json
        body:
          email: "{{ flowise_admin_user.email }}"
          password: "{{ flowise_admin_user.password }}"
        # if user doesn't exist, response will
        # be 404 and .message="User Not Found"
        status_code: [200, 404]
      register: admin_auth

    - name: Create Flowise admin user
      when: admin_auth.status == 404
      block:
        - name: Create Flowise admin user
          ansible.builtin.uri:
            method: POST
            url: "{{ api_base }}/account/register"
            body_format: json
            body:
              user:
                type: pro
                name: "{{ flowise_admin_user.name }}"
                email: "{{ flowise_admin_user.email }}"
                credential: "{{ flowise_admin_user.password }}"
            # unlike other "create" APIs, this
            # one actually returns correct 201
            status_code: 201
          register: admin_reg
          changed_when: admin_reg.status == 201

        # register API doesn't return session
        # cookies, so need to reauthenticate
        - name: Reauthenticate admin user
          ansible.builtin.uri:
            method: POST
            url: "{{ api_base }}/auth/login"
            body_format: json
            body:
              email: "{{ flowise_admin_user.email }}"
              password: "{{ flowise_admin_user.password }}"
          register: admin_reauth

    - name: Set admin auth_headers fact
      vars:
        user: |
          {{ admin_auth.json if admin_auth.json is defined else admin_reauth.json }}
        cookies: >-
          {{ admin_auth.cookies_string if admin_auth.cookies_string is defined else
           admin_reauth.cookies_string }}
      ansible.builtin.set_fact:
        auth_headers:
          # uri result: .cookies is a dictionary and
          #.cookies_string is ;-delimited name=value
          Cookie: "{{ cookies }}"
          X-Request-From: internal
        admin_user: "{{ {
          'id':    user.id,
          'name':  user.name,
          'email': user.email,
          } }}"
        admin_role: "{{ {
          'id':    user.roleId,
          'name':  user.assignedWorkspaces[0].role,
          } }}"
        organization: "{{ {
          'id':    user.activeOrganizationId,
          'name': 'Default Organization',
          } }}"
        workspace: "{{ {
          'id':    user.activeWorkspaceId,
          'name':  user.activeWorkspace,
          } }}"
        # use different (all caps) name for fact to prevent
        # errors due to facts having higher precedence than
        # vars with the same name at the play level
        API_BASE: "{{ api_base }}"

    - name: Get third-party credentials
      ansible.builtin.uri:
        url: "{{ api_base }}/credentials"
        headers: "{{ auth_headers }}"
        return_content: true
      register: get_creds

    - name: Add third-party credentials
      vars:
        existing: "{{ get_creds.json | map(attribute='name') }}"
        add_creds: |
          {% set creds = [] %}
          {% for cred in flowise_external_credentials %}
          {%   if cred.name not in existing %}
          {%     set _ = creds.append(cred) %}
          {%   endif %}
          {% endfor %}
          {{ creds  }}
      ansible.builtin.uri:
        method: POST
        url: "{{ api_base }}/credentials"
        headers: "{{ auth_headers }}"
        body_format: json
        body:
          name: "{{ item.name }}"
          credentialName: "{{ item.type }}"
          plainDataObj: "{{ item.data }}"
        return_content: true
      loop: "{{ add_creds }}"
      loop_control:
        label: "{{ item.name }}"
      register: add_cred
      changed_when: add_cred.status == 200

    - name: Set external_credentials fact
      ansible.builtin.set_fact:
        external_credentials: |
          {% set creds = get_creds.json   %}
          {% for cred in add_cred.results %}
          {%   set _ = creds.append(cred.json) %}
          {% endfor %}
          {{ creds  }}

    - name: Get Flowise document stores
      ansible.builtin.uri:
        url: "{{ api_base }}/document-store/store"
        headers: "{{ auth_headers }}"
        return_content: true
      register: get_stores

    - name: Create Accounts document store
      vars:
        store: "{{ get_stores.json | selectattr('name', '==', doc_store_name) }}"
      ansible.builtin.uri:
        method: POST
        url: "{{ api_base }}/document-store/store"
        headers: "{{ auth_headers }}"
        body_format: json
        body:
          name: "{{ doc_store_name }}"
          description: Confidential information and notable events about various accounts
        return_content: true
      when: store is not truthy
      register: create_store
      changed_when: create_store.status == 200

    # pass var to the next play since
    # scope of registered variable in
    # Ansible is limited to this play
    - name: Set accounts_doc_store fact
      vars:
        store: "{{ get_stores.json | selectattr('name', '==', doc_store_name) }}"
      ansible.builtin.set_fact:
        accounts_doc_store: |
          {{ store | first if store is truthy else create_store.json }}

    - name: Get Flowise database secret
      delegate_to: "{{ rke_control_plane_host }}"
      vars:
        # required kubernetes>=24.2 package only in user virtualenv
        ansible_python_interpreter: "{{ venv_python_interpreter }}"
      # https://docs.ansible.com/ansible/latest/collections/kubernetes/core/k8s_info_module.html
      kubernetes.core.k8s_info:
        kubeconfig: "{{ rke_kubeconfig }}"
        api_version: v1
        kind: Secret
        name: "{{ flowise_secrets['database'] }}"
        namespace: "{{ flowise_namespace }}"
      register: db_secret

    - name: Set vector_store_config fact
      vars:
        qdrant_cred_id: "{{   external_credentials |
          selectattr('credentialName', '==', 'qdrantApi')   | map(attribute='id') | first }}"
        postgres_cred_id: "{{ external_credentials |
          selectattr('credentialName', '==', 'PostgresApi') | map(attribute='id') | first }}"
        secret_data: "{{ db_secret.resources[0].data }}"
        postgres_ssl_config:
          # these properties are options from the
          # DataSource class of `typeorm` package:
          # https://typeorm.io/docs/drivers/postgres
          ssl:
            rejectUnauthorized: false
            # base64-encoded PEM data
            cert: "{{ secret_data['tls.crt'] }}"
            key: "{{ secret_data['tls.key'] }}"
            ca: "{{ secret_data['ca.crt'] }}"
        ollama_config:
          baseUrl: "{{ ollama_service_url }}"
          # must be exact and include tag,
          # and already pulled into Ollama
          modelName: nomic-embed-text:v1.5
          # numGpu: ""
          # numThread: ""
          useMMap: true
        qdrant_config:
          qdrantServerUrl: "{{ qdrant_service_url }}"
          credential: "{{ qdrant_cred_id }}"
          qdrantCollection: flowise_documents
          # qdrantCollectionConfiguration: ""
          # dimensions must be supported
          # by the selected Ollama model
          qdrantVectorDimension: 768
          qdrantSimilarity: Cosine
          # qdrantFilter: ""
          # topK: ""
          contentPayloadKey: content
          metadataPayloadKey: metadata
          fileUpload: true
          batchSize: 10
        postgres_config:
          host: "{{ pgpool_service_host }}"
          port: "{{ pgpool_service_port }}"
          database: "{{ flowise_db_name }}"
          credential: "{{ postgres_cred_id }}"
          # this must be false, or else Flowise
          # will set {ssl:true} and clobber our
          # additionalConfig object {ssl:{...}}
          ssl: false
          additionalConfig: "{{ postgres_ssl_config | to_json }}"
          # namespace: ""
          tableName: upsert_records
          sourceIdKey: source
          cleanup: none
      ansible.builtin.set_fact:
        vector_store_config:
          storeId: "{{ accounts_doc_store.id }}"
          embeddingName: ollamaEmbedding
          embeddingConfig: "{{ ollama_config }}"
          vectorStoreName: qdrant
          vectorStoreConfig: "{{ qdrant_config }}"
          recordManagerName: postgresRecordManager
          recordManagerConfig: "{{ postgres_config }}"

    - name: Save new vector store config
      vars:
        old: "{{ accounts_doc_store }}"
        new: "{{ vector_store_config }}"
      ansible.builtin.uri:
        method: POST
        url: "{{ api_base }}/document-store/vectorstore/save"
        headers: "{{ auth_headers }}"
        body_format: json
        body: "{{ new }}"
      when: >-
        old.embeddingConfig        is not truthy or
        old.embeddingConfig.config     | to_json !=
        new.embeddingConfig            | to_json or
        old.vectorStoreConfig      is not truthy or
        old.vectorStoreConfig.config   | to_json !=
        new.vectorStoreConfig          | to_json or
        old.recordManagerConfig    is not truthy or
        old.recordManagerConfig.config | to_json !=
        new.recordManagerConfig        | to_json
      register: save_config
      changed_when: save_config.status == 200
  any_errors_fatal: true

- name: Update Accounts document store
  # must run after previous play to get
  # auth headers & document store facts
  tags: documents
  hosts: localhost
  gather_facts: false
  vars:
    # this var can be set on the command line
    # to limit the number of files to process
    limit: 0
    # PLAYBOOKS and TAGS are global vars
    # injected by play.sh wrapper script
    playbooks: |
      {{  PLAYBOOKS | split(',') if PLAYBOOKS is defined and PLAYBOOKS is truthy else [] }}
    tags_: "{{ TAGS | split(',') if      TAGS is defined and      TAGS is truthy else [] }}"
    api_base: "{{ API_BASE }}"
  pre_tasks:
    - name: Load documents or skip upload?
      ansible.builtin.set_fact:
        do_upload: >-
          {{ playbooks | length == 1  and
             'flowise'   in playbooks and
             'documents' in tags_ }}
  tasks:
    - name: Find ~/accounts/*.txt files
      when: do_upload
      # ansible_user_dir will
      # be set on 'localhost'
      delegate_to: cosmos
      block:
        - name: Gather facts about user_dir
          # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html
          ansible.builtin.setup:
            gather_subset: user_dir

        - name: Find ~/accounts/*.txt files
          # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/find_module.html
          ansible.builtin.find:
            paths: ~/accounts/
            follow: true
            recurse: true
            patterns: "*.txt"
          register: find_files

        - name: Load new document content
          vars:
            # ansible_user_dir for 'cosmos'
            # set by ansible.builtin.setup
            accts_dir: "{{ ansible_user_dir }}/accounts/"
            acct_files: |
              {% set files  = [] %}
              {# use namespace() to create a scoped object #}
              {# https://jinja.palletsprojects.com/en/stable/templates/#assignments #}
              {% set ns = namespace(
                  sorted=find_files.files | sort(attribute='mtime', reverse=true)) %}
              {% if limit|int > 0 and limit|int < ns.sorted | length %}
              {%   set ns.sorted = ns.sorted[:limit|int] %}
              {% endif %}
              {% set total  = ns.sorted | length %}
              {% set n      = accts_dir | length %}
              {% for i  in range(total)    %}
              {%   set file = ns.sorted[i] %}
              {%   set _    = files.append({
                    'label': (i + 1) ~'/'~ total ~'|'~ file.path[n:],
                    'path':  file.path,
                   })   %}
              {% endfor %}
              {{ files  }}
          # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/slurp_module.html
          ansible.builtin.slurp:
            src: "{{ item.path }}"
          loop: "{{ acct_files }}"
          loop_control:
            label: "{{ item.label }}"
          # file_data.results[].content
          # will be base64-encoded!
          register: file_data

    - name: Create new document loader
      when: do_upload
      block:
        - name: Delete old document loader
          vars:
            # accounts_doc_store.loaders is both string and sequence
            # ('[]') if from create_store.json, but is only sequence
            # if from get_stores.json
            loader: |
              {{ accounts_doc_store.loaders | selectattr('loaderId', '==', 'textFile')
              if accounts_doc_store.loaders is not string else [] }}
          ansible.builtin.uri:
            method: DELETE
            url: "{{ api_base }}/document-store/loader/{{
              accounts_doc_store.id }}/{{ loader | map(attribute='id') | first }}"
            headers: "{{ auth_headers }}"
          when: loader is truthy
          register: delete_loader
          changed_when: delete_loader.status == 200

        - name: Set new loader_spec fact
          vars:
            text_files: |
              {% set files = [] %}
              {% for file in file_data.results %}
              {%   set _ = files.append('data:text/plain;base64,'~ file.content
                                      ~',filename:'~ file.source | basename) %}
              {% endfor %}
              {{ files  }}
          ansible.builtin.set_fact:
            loader_spec:
              storeId: "{{ accounts_doc_store.id }}"
              loaderId: textFile
              loaderName: "*.txt Files"
              loaderConfig:
                txtFile: "{{ text_files | to_json }}"
              splitterId: recursiveCharacterTextSplitter
              splitterName: Recursive Character Text Splitter
              splitterConfig:
                chunkSize: 500
                chunkOverlap: 100

        - name: Save new document loader
          ansible.builtin.uri:
            method: POST
            url: "{{ api_base }}/document-store/loader/save"
            headers: "{{ auth_headers }}"
            body_format: json
            body: "{{ loader_spec }}"
            return_content: true
          register: save_loader
          changed_when: save_loader.status == 200

        - name: Process document chunks
          ansible.builtin.uri:
            method: POST
            url: "{{ api_base }}/document-store/loader/process/{{ save_loader.json.id }}"
            headers: "{{ auth_headers }}"
            body_format: json
            body: "{{ loader_spec }}"
          register: process_docs
          changed_when: process_docs.status == 200

        - name: Wait until status is SYNC
          ansible.builtin.uri:
            url: "{{ api_base }}/document-store/store/{{ loader_spec.storeId }}"
            headers: "{{ auth_headers }}"
            return_content: true
          register: check_status
          until: >-
            check_status.json is defined and
            check_status.json.status | default('') == 'SYNC'
          # processing can take few minutes
          retries: 20
          delay: 15

        - name: Show document store stats
          vars:
            store: "{{ check_status.json }}"
            loader: "{{ store.loaders | selectattr('loaderId', '==', 'textFile') | first }}"
            # NOTE: loaders[].files property is
            # only available if .status is SYNC
            files: "{{ loader.files }}"
          # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html
          ansible.builtin.debug:
            msg: |-
              Document  store     ID: {{ store.id          }}
              Document  store   name: {{ store.name        }}
              Document  store status: {{ store.status      }}
              Total documents stored: {{ files | length    }}
              Total document  chunks: {{ store.totalChunks }}
              Total characters  read: {{ store.totalChars  }}

        # depending on how many NEW or UPDATED chunks,
        # this request could take a very long time due
        # to slow calls to Ollama to create embeddings
        - name: Upsert chunks into Qdrant
          ansible.builtin.uri:
            method: POST
            url: "{{ api_base }}/document-store/vectorstore/insert"
            headers: "{{ auth_headers }}"
            body_format: json
            # body is same as save
            # API in previous play
            body: "{{ vector_store_config }}"
            return_content: true
            timeout: 3600
          timeout: 3600
          register: upsert_chunks
          changed_when: >-
            upsert_chunks.json.numSkipped <
            upsert_chunks.json.totalKeys
          until: upsert_chunks.status == 200
          retries: 3
          delay: 30

        - name: Show Qdrant upsert results
          vars:
            result: "{{ upsert_chunks.json }}"
          ansible.builtin.debug:
            msg: |-
              Chunks   added: {{ result.numAdded   }}
              Chunks updated: {{ result.numUpdated }}
              Chunks skipped: {{ result.numSkipped }}
              Chunks deleted: {{ result.numDeleted }}
              Total   chunks: {{ result.totalKeys  }}
  any_errors_fatal: true

- name: Create chatflows and agentflows
  tags: configure
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/kubernetes.yml
    - vars/ollama.yml
  vars:
    api_base: "{{ API_BASE }}"
    chatflow_name: Accounts Assistant
  tasks:
    - name: Get all Flowise chatflows
      ansible.builtin.uri:
        url: "{{ api_base }}/chatflows"
        headers: "{{ auth_headers }}"
        return_content: true
      register: get_chatflows

    - name: Create Accounts chatflow
      vars:
        chatflow: "{{ get_chatflows.json | selectattr('name', '==', chatflow_name) }}"
      ansible.builtin.uri:
        method: POST
        url: "{{ api_base }}/chatflows"
        headers: "{{ auth_headers }}"
        body_format: json
        body:
          name: "{{ chatflow_name }}"
          type: CHATFLOW
          isPublic: false
          deployed: false
          flowData: '{"nodes":[],"edges":[],"viewport":{"x":0,"y":0,"zoom":1}}'
        return_content: true
      when: chatflow is not truthy
      register: create_chatflow
      changed_when: create_chatflow.status == 200

    - name: Set accounts_chatflow fact
      vars:
        chatflow: "{{ get_chatflows.json | selectattr('name', '==', chatflow_name) }}"
      ansible.builtin.set_fact:
        accounts_chatflow: |
          {{ chatflow | first if chatflow is truthy else create_chatflow.json }}

    - name: Import nodes into chatflow
      vars:
        ollama_model: deepseek-r1:1.5b
        doc_store_id: "{{ accounts_doc_store.id }}"
        # NOTE: using non-standard variable markers
        # [% and %] to avoid conflicts with Flowise:
        # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_lookup.html
        flow_data: >-
          {{ lookup('ansible.builtin.template',
               template_dir ~ '/flowise/chatflow.yaml.j2',
               variable_start_string='[%',
               variable_end_string='%]') |
             from_yaml | to_json }}
      ansible.builtin.uri:
        method: PUT
        url: "{{ api_base }}/chatflows/{{ accounts_chatflow.id }}"
        headers: "{{ auth_headers }}"
        body_format: json
        body:
          name: "{{ accounts_chatflow.name }}"
          flowData: "{{ flow_data }}"
      when: accounts_chatflow.flowData != flow_data
      register: import_nodes
      changed_when: import_nodes.status == 200
  any_errors_fatal: true
